Frequently Asked Questions regarding the Resume Randomizer

******************
Question 1) Does the Resume Randomizer work on non-Windows operating systems?

Answer 1) The program should run on any modern OS (Windows, Linux, Mac, etc).

Specifically, the executable file (resume-randomizer.exe, if you have it) will only run on Windows, but the source code (resume-randomizer.py) is provided alongside the executable and can be run via the Python programming environment.
To do so, download and install Python version 3.6 or higher. I recommend using the Anaconda distribution because it comes bundled with many useful libraries.  https://www.anaconda.com/download/

Once Python is installed and associated with .py file types you should be able to just run the resume-randomizer.py file from the GUI (i.e., double-click on it), or in the Anaconda command line type "python resume-randomizer.py".  This website has more info about using Python on a Mac. https://docs.python.org/3/using/mac.html ..either drag the .py file onto PythonLauncher, or use the finder Info window to set PythonLauncher as the default application to open the file (or any .py file) (and then double-click the py file).
If it complains with errors about "ModuleNotFoundError: No module named 'numpy'" (or 'pandas' or whatever module), then on the command line type 'conda install numpy' (or whatever module).

As an alternative, it may be possible to use WINE to run the exe file on Linux, Mac, & BSD, but that has not been tested. https://www.winehq.org/

The front-end GUI, resume-randomizer.html, is a webpage and should work on any OS and the majority of web browsers, although the necessary scripts will not necessarily work with all web browsers.  The GUI has only been verified to work on Firefox, Chrome, Safari, Internet Explorer, and Microsoft Edge.

******************
Question 2) How do I make the resumes look professional, with different fonts, font sizes, italics, images, backgrounds, etc?

Answer 2) The resumes that the program creates are all plain-text files (even though the file ends in .doc).  So they're just letters, spaces, numbers, and symbols.  They don't have any formatting, otherwise they would be "rich text" instead of "plain text."
We know of three approaches to create random resumes with formatting:

The first approach is to do it all manually, which is theoretically do-able, but would take too long with any reasonable number of resumes.

The second approach is to write the template so that it creates resumes that have the information that another program can use to apply the formatting.  That's what I recommend in both Example 12 (formatting resumes using templates that generate HTML), and in Example 14 (TeX for formatting).  Regardless of what language/approach is used, there's going to have to be an additional step that converts the plain-text resumes generated by the program into rich-text files (pdfs, gifs, Word docs, or whatever).

Personally, I prefer following Example 14, generating resume files that contain TeX commands, and then using pdftex  (https://www.tug.org/applications/pdftex/  though I actually use it as part of MiKTeX http://miktex.org/  )  to turn those resume files into pdfs with all the formatting.  Converting all the resumes just requires running a command like "pdftex *.doc" in the console, once pdftex has been installed correctly.  So the user does not need to manually operate on each resume...but will need to run a batch conversion command once.
The downside of this approach is that if one does not know TeX it can be difficult to learn how to apply formatting (e.g., how to bold a word).  But if you look at the Example 14 template, you can see that formatting can be put directly into the resumes so it's either the same for all resumes (like Leaf 1-1 with the documentclass that sets the 12pt font size) or different for different resumes (like Random 1-2 which randomly chooses a font).

Similarly, HTML files can be printed/saved to images or pdfs...just search for something like "batch html to pdf" on the internet.  Then follow Example 12 to generate the resumes, and once the resumes are created batch convert them into pdfs or images or some other filetype that shows the formatting.

The third approach is to use the Resume Randomizer just to generate the random texts, and then to use "mail merge" to put those input text snippets into a formatted document.  The mail merge technique has been used for decades to fill form letters with input text, and is supported by most popular word processors, such as Microsoft Word.  We have not tried this approach, but it has been done by others.

See the Advanced Use section on "Formatting resumes" for more explanation on this topic.


******************
Question 3) Can the Resume Randomizer handle other languages?  How do I make resumes that contain text (character sets/encoding) other than US English (e.g., Cyrillic)?

Answer 3) Yes, the Resume Randomizer can use template and fragment files that were saved in different encodings.  First it attempts to load each file using the system preferred encoding, which is typically a version of ASCII on Windows, or utf-8 on Linux and macOS. If that encoding fails, the program attempts to "guess" the encoding using the chardet library http://chardet.readthedocs.io/en/latest/index.html

For example, the provided example template named "example_cyrillic_template.rtf" has been used to generate non-ASCII resumes on a Windows computer with ASCII as the preferred encoding.

All of the output files will use the same encoding as each other.
If one encoding can open the template file and any fragment file used in that template, then all of the output files will use that encoding.
If the template file uses fragments and multiple encodings are necessary to read the template and fragments, then the program will attempt to write the codebook using each of those encodings until it finds one that works, and will then use that encoding for all the output files.
If none of the encodings used to read the input files can encode the codebook, then the program will attempt to use utf-8.  If even utf-8 cannot encode all the Leaf text, the program will fail with an error.  In that case, try using Unicode encodings on the input files, or create a template that does not use fragment files since that way there is only one encoding for all of the input text.

Some encodings are easier to detect than others, so if the program prints an error message about failing to read a file with either the default encoding or the best guess, try saving your template and fragment files as Unicode (e.g., UTF-8 encoding), which is easy for chardet to identify. Personally I use the text editor Emacs to change encodings of files.  https://www.gnu.org/software/emacs/

If you run into issues with other languages or character encodings, please let us know and we will investigate the situation further.

For an overview on the software history of character encodings see http://www.joelonsoftware.com/articles/Unicode.html
For some Python programmatic details see https://docs.python.org/3/howto/unicode.html
For more about Unicode see http://unicode.org/faq/basic_q.html
