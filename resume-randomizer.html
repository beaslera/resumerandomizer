<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">
<HTML>
<HEAD>
<TITLE>Resume Randomizer Template Generator</TITLE>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">

<style type="text/css">
  #leftSide {
  border-right: 1px solid gray;
  height: 95vh;
  overflow-y: scroll;
  vertical-align: top;
  width: 75%;
  }
  
  #sidebar {
  height: 95vh;
  overflow: scroll;
  width: 25%
  }

  #content {
  display: inline-flex;
  }
  
  textarea{
  width: 95%;
  }

  randomStart {
  display: table;
  margin: 1pt;
  border-style: solid;
  border-width: 3pt;
  border-color: #333;
  padding: 1px;
  }
  
  randomSub {
  display: table;
  margin: 1pt;
  border-style: solid;
  border-width: 2pt;
  border-color: #888;
  padding: 1px;
  }
  
  dependentStart {
  display: table;
  margin: 1pt;
  border-style: dashed;
  border-radius: 1em/5em;
  border-width: 3pt;
  border-color: #333;
  padding: 1px;
  }
  
  dependentSub {
  display: table;
  margin: 1pt;
  border-style: solid;
  border-radius: 1em/5em;
  border-width: 2pt;
  border-color: #888;
  padding: 1px;
  }
  
  emptySub {
  background-color: #888;
  }
  
  hidden {
  display: none;
  }
</style>

<SCRIPT type="text/javascript">
//If you can read this on your web browser, javascript is not working.  Fix javascript on your web browser.

var versionNumber = 30;
var template = new Array();

// countId is an Array that contains the number of subpoints at each level.
var countId;

/**
 * Writes the current ID by concatenating the values in countId.
 */
function writeId() {
    var tempString = "";
    var runOnce = 0;
    for (var countStr = 0; countStr < countId.length; countStr++) {
	if (runOnce == 0) runOnce = 1;
	else tempString += "-";
	tempString += countId[countStr];
    }
    return tempString;
}

/**
 * Updates the template from the GUI starting from the current ID (stored in countId).
 */
function recursiveUpdate() {
    var tempId = document.getElementById('type'+writeId());
    if (tempId == null) return -1;
    var myValue = tempId.options[tempId.selectedIndex].value;
    template.length++;

    if (myValue == "*leaf*") {
	template[template.length-1] = myValue + " " + writeId();
	var tempIdLeaf = document.getElementById("leaf"+writeId());
	if (tempIdLeaf != null) {
	    var leafText = tempIdLeaf.value;
	    if (leafText != "") {
		var leafArray = leafText.split("\n");
		template.length += leafArray.length;
		for (var countArr = 0; countArr < leafArray.length; countArr++) template[template.length-(leafArray.length - countArr)] = leafArray[countArr];
	    }
	}
	template.length++;
	template[template.length-1] = "*end_" + myValue.substring(1,myValue.length) + " " + writeId();
    }

    if ((myValue == "*random*") || (myValue == "*constant*") || (myValue == "*dependent*")) {
	var tempIdNum = document.getElementById("num"+writeId());
	if (tempIdNum == null) var numChoices = 2;
	else var numChoices = tempIdNum.options[tempIdNum.selectedIndex].value;
	var hasMaster = false;
	var hidden = false;
	var tempIdHidden = document.getElementById("hidden"+writeId());
	if (tempIdHidden != null) hidden = tempIdHidden.checked;
	var matched = false;
	var repeat = false;
	var repeatSame = false;
	var repeatNever = false;
	var repeatNoDoubles = false;
	var repeatDifferentDouble = false;
	var matchSame = false;
	var matchDifferent = false;
	var matchOnlyOneEver = false;
	var minimumNumberOfEntries = 0;
	var maximumNumberOfEntries = 0;
	var matchMaxSelectionsPerSubPoint = false;
	var maxSelectionsPerSubPointInteger = 0;
	var nonUniformFirstSubPoint = false;

	if (myValue == "*random*") {
	    var tempIdRepeat = document.getElementById("repeat"+writeId());
	    if (tempIdRepeat != null) repeat = tempIdRepeat.checked;
	    var tempIdRepeatSame = document.getElementById("repeatSame"+writeId());
	    if (tempIdRepeatSame != null) repeatSame = tempIdRepeatSame.checked;
	    var tempIdRepeatNever = document.getElementById("repeatNever"+writeId());
	    if (tempIdRepeatNever != null) repeatNever = tempIdRepeatNever.checked;
	    var tempIdRepeatNoDoubles = document.getElementById("repeatNoDoubles"+writeId());
	    if (tempIdRepeatNoDoubles != null) repeatNoDoubles = tempIdRepeatNoDoubles.checked;
	    var tempIdRepeatDifferentDouble = document.getElementById("repeatDifferentDouble"+writeId());
	    if (tempIdRepeatDifferentDouble != null) repeatDifferentDouble = tempIdRepeatDifferentDouble.checked;
	    if (repeatSame && repeatNever) {
		alert("Cannot set both Same If Repeat and Always Different If Repeat");
		repeatSame = false;
		repeatNever = false;
	    }
	    if (repeatSame && repeatDifferentDouble) {
		alert("Cannot set both Same If Repeat and Non-Uniform Chance For Immediate Repeat");
		repeatSame = false;
		repeatDifferentDouble = false;
	    }
	    if (repeatNever && repeatDifferentDouble) {
		alert("Cannot set both Always Different If Repeat and Non-Uniform Chance For Immediate Repeat");
		repeatNever = false;
		repeatDifferentDouble = false;
	    }
	    if (repeatDifferentDouble) {
	    	var tempIdRepeatDifferentDoublePercentage = document.getElementById("repeatDifferentDoublePercentage"+writeId());
	    	var repeatDifferentDoublePercentage = 50.0;
	    	if (tempIdRepeatDifferentDoublePercentage != null) {
	    	    repeatDifferentDoublePercentage = Number(tempIdRepeatDifferentDoublePercentage.value);
	    	    if (isNaN(repeatDifferentDoublePercentage)) {
	    		alert("The percent chance for an immediate repeat (section " + writeId() + ", current value '" + tempIdRepeatDifferentDoublePercentage.value + "') must be a number. To disable the setting, uncheck the checkbox to the left. The value has been set to 50.")
	    		repeatDifferentDoublePercentage = 50.0;
	    	    }
	    	    if (repeatDifferentDoublePercentage > 100.0) {
	    		alert("Cannot set the percent chance for an immediate repeat (section " + writeId() + ", current value '" + tempIdRepeatDifferentDoublePercentage.value + "') above 100. The value has been set to 100.")
	    		repeatDifferentDoublePercentage = 100.0;
	    	    }
	    	    if (repeatDifferentDoublePercentage < 0.0) {
	    		alert("Cannot set the percent chance for an immediate repeat (section " + writeId() + ", current value '" + tempIdRepeatDifferentDoublePercentage.value + "') below 0. The value has been set to 0.")
	    		repeatDifferentDoublePercentage = 0.0;
	    	    }
	    	}
	    }

	    var tempIdNonUniformFirstSubPoint = document.getElementById("nonUniformFirstSubPoint"+writeId());
	    if (tempIdNonUniformFirstSubPoint != null) nonUniformFirstSubPoint = tempIdNonUniformFirstSubPoint.checked;
	    if (nonUniformFirstSubPoint) {
	    	var tempIdNonUniformFirstSubPointPercentage = document.getElementById("nonUniformFirstSubPointPercentage"+writeId());
	    	var nonUniformFirstSubPointPercentage = 50.0;
	    	if (tempIdNonUniformFirstSubPointPercentage != null) {
	    	    nonUniformFirstSubPointPercentage = Number(tempIdNonUniformFirstSubPointPercentage.value);
	    	    if (isNaN(nonUniformFirstSubPointPercentage)) {
	    		alert("The percent change for the first sub-point (section " + writeId() + ", current value '" + tempIdNonUniformFirstSubPointPercentage.value + "') must be a number. To disable the setting, uncheck the checkbox to the left. The value has been set to 50.")
	    		nonUniformFirstSubPointPercentage = 50.0
	    	    }
	    	    if (nonUniformFirstSubPointPercentage > 100.0) {
	    		alert("Cannot set the percent chance for the first sub-point (section " + writeId() + ", current value '" + tempIdNonUniformFirstSubPointPercentage.value + "') above 100. The value has been set to 100.")
	    		nonUniformFirstSubPointPercentage = 100.0;
	    	    }
	    	    if (nonUniformFirstSubPointPercentage < 0.0) {
	    		alert("Cannot set the percent chance for the first sub-point (section " + writeId() + ", current value '" + tempIdNonUniformFirstSubPointPercentage.value + "') below 0. The value has been set to 0.")
	    		nonUniformFirstSubPointPercentage = 0.0;
	    	    }
	    	}
	    }
	    
	    var tempIdMatched = document.getElementById("matched"+writeId());
	    if (tempIdMatched != null) matched = tempIdMatched.checked;
	    if (matched) {
		var tempIdMatchOnlyOneEver = document.getElementById("matchOnlyOneEver"+writeId());
		if (tempIdMatchOnlyOneEver == null) {
		    matchOnlyOneEver = false;
		} else {
		    matchOnlyOneEver = tempIdMatchOnlyOneEver.checked;
		}
		var tempIdMatchDifferent = document.getElementById("matchDifferent"+writeId());
		if (tempIdMatchDifferent == null) {
		    matchDifferent = false;
		} else {
		    matchDifferent = tempIdMatchDifferent.checked;
		}
		var tempIdMatchSame = document.getElementById("matchSame"+writeId());
		if (tempIdMatchSame == null) {
		    matchSame = false;
		} else {
		    matchSame = tempIdMatchSame.checked;
		}

		var tempIdMatchMaxSelectionsPerSubPoint = document.getElementById("matchMaxSelectionsPerSubPoint"+writeId());
		if (tempIdMatchMaxSelectionsPerSubPoint != null) matchMaxSelectionsPerSubPoint = tempIdMatchMaxSelectionsPerSubPoint.checked;
		if (matchMaxSelectionsPerSubPoint) {
		    var tempIdMaxSelectionsPerSubPointInteger = document.getElementById("maxSelectionsPerSubPointInteger"+writeId());
		    if (tempIdMaxSelectionsPerSubPointInteger != null) {
			maxSelectionsPerSubPointInteger = parseInt(Number(tempIdMaxSelectionsPerSubPointInteger.value));
			if (isNaN(maxSelectionsPerSubPointInteger) || (maxSelectionsPerSubPointInteger < 0)) {
			    alert("MatchMaxSelectionsPerSubPoint must be an integer greater than or equal to zero, for Random section " + writeId());
			    maxSelectionsPerSubPointInteger = 0;
			}
		    }
		}

		if ((matchSame && matchDifferent) || (matchSame && matchOnlyOneEver) || (matchSame && matchMaxSelectionsPerSubPoint) || (matchDifferent && matchOnlyOneEver) || (matchDifferent && matchMaxSelectionsPerSubPoint) || (matchDifferent && matchMaxSelectionsPerSubPoint)) {
		    alert("Cannot have more than one match requirement (e.g., MatchSame, MatchDifferent) for Random section " + writeId());
		    matchSame = true
		    matchDifferent = false;
		    matchOnlyOneEver = false;
		    matchMaxSelectionsPerSubPoint = false;
		}
		if (!matchSame && !matchDifferent && !matchOnlyOneEver && !matchMaxSelectionsPerSubPoint) {
		    matchSame = true
		}
	    }

	    if (repeat) {
		var tempIdRepeatStart = document.getElementById("repeatStart"+writeId());
		if (tempIdRepeatStart == null) var repeatStart = 0;
		else {
		    var repeatStart = Number(tempIdRepeatStart.value);
		    if (isNaN(repeatStart)) {
			repeatStart = 0;
			alert("repeatStart"+writeId()+" is not a number!");
		    }
		}
		var tempIdRepeatEnd = document.getElementById("repeatEnd"+writeId());
		if (tempIdRepeatEnd == null) var repeatEnd = 1;
		else {
		    var repeatEnd = Number(tempIdRepeatEnd.value);
		    if (isNaN(repeatEnd)) {
			repeatEnd = 1;
			alert("repeatEnd"+writeId()+" is not a number!");
		    }
		}
		var tempIdRepeatInterval = document.getElementById("repeatInterval"+writeId());
		if (tempIdRepeatInterval == null) var repeatInterval = 1;
		else {
		    var repeatInterval = Number(tempIdRepeatInterval.value);
		    if (isNaN(repeatInterval)) {
			repeatInterval = 1;
			alert("repeatInterval"+writeId()+" is not a number!");
		    }
		    if (repeatInterval == 0) {
			repeatInterval = 1;
			alert("repeatInterval"+writeId()+" cannot be zero!");
		    }
		}
		if (repeatNoDoubles) {
		    var tempIdMinimumNumberOfEntries = document.getElementById("minimumNumberOfEntries"+writeId());
		    if (tempIdMinimumNumberOfEntries != null) {
			minimumNumberOfEntries = parseInt(Number(tempIdMinimumNumberOfEntries.value));
			if (isNaN(minimumNumberOfEntries)) {
			    minimumNumberOfEntries = 0;
			    alert("minimumNumberOfEntries"+writeId()+" is not a number!");
			}
		    }
		    var tempIdMaximumNumberOfEntries = document.getElementById("maximumNumberOfEntries"+writeId());
		    if (tempIdMaximumNumberOfEntries != null) {
			maximumNumberOfEntries = parseInt(Number(tempIdMaximumNumberOfEntries.value));
			if (isNaN(maximumNumberOfEntries)) {
			    maximumNumberOfEntries = 0;
			    alert("maximumNumberOfEntries"+writeId()+" is not a number!");
			}
		    }
		}
	    }
	}

	if (myValue == "*dependent*") {
	    hasMaster = true;
	    var masterId = null;
            var tempIdMaster = document.getElementById("master"+writeId());
	    if (tempIdMaster != null) var masterId = tempIdMaster.options[tempIdMaster.selectedIndex].value;
	    else { //this dependent section does not have a master selector element yet, must be new
		for (var lineInTemplate = 0; lineInTemplate < template.length - 1; lineInTemplate++) {
		    splitLine = template[lineInTemplate].split(" ");
		    if (splitLine[0] == "*random*") {	    //find the first random section
			masterId = splitLine[1];
			break;
		    }
		}
	    }
	    if (masterId != null) {
		var tempMasterIdNum = document.getElementById("num"+masterId);
		// is the master section still a random section?  If it just changed, we need to look for a new master.
		var masterIsRandom = false;
		for (var lineInTemplate = 0; lineInTemplate < template.length - 1; lineInTemplate++) {
		    splitLine = template[lineInTemplate].split(" ");
		    if (splitLine[0] == "*random*") {
			if (masterId == splitLine[1]) {
			    masterIsRandom = true;
			    break;
			}
		    }
		}
		if (masterIsRandom) {
		    // if you make a dependent section before any random
		    // sections, and then you add a random section, for the
		    // first update you will have a masterId, but that new
		    // random section will not yet have a number of
		    // subelements select element.
		    if (tempMasterIdNum != null)  numChoices = tempMasterIdNum.options[tempMasterIdNum.selectedIndex].value;
		} else {
		    masterId = null;
		    for (var lineInTemplate = 0; lineInTemplate < template.length - 1; lineInTemplate++) {
			splitLine = template[lineInTemplate].split(" ");
			if (splitLine[0] == "*random*") {	    //find the first random section
			    masterId = splitLine[1];
			    if (tempMasterIdNum != null)  numChoices = tempMasterIdNum.options[tempMasterIdNum.selectedIndex].value;
			    break;
			}
		    }
		}
	    }
	    if (masterId == null) {
		alert("The dependent section " + writeId() + " does not have a random section on which to depend.\nYou must have at least one random section before any dependent sections.");
	    }
	}
	template[template.length-1] = myValue + " " + writeId() + " " + numChoices;
	if (hidden) template[template.length-1] += " *hide*";
	if (matchMaxSelectionsPerSubPoint) template[template.length-1] += " *matchMaxSelectionsPerSubPoint* " + maxSelectionsPerSubPointInteger;
	if (nonUniformFirstSubPoint) template[template.length-1] += " *nonUniformFirstSubPoint* " + nonUniformFirstSubPointPercentage;
	if (repeatSame) template[template.length-1] += " *repeatSame*";
	if (repeatNever) template[template.length-1] += " *repeatNever*";
	if ((repeatNoDoubles) && (!repeatNever)) {
	    template[template.length-1] += " *repeatNoDoubles*";
	    if (!repeatSame) {
		if (minimumNumberOfEntries > 0) template[template.length-1] += " *minimumNumberOfEntries* " + minimumNumberOfEntries;
		if (maximumNumberOfEntries > 0) template[template.length-1] += " *maximumNumberOfEntries* " + maximumNumberOfEntries;
	    }
	}
	if (repeatDifferentDouble) template[template.length-1] += " *repeatDifferentDouble* " + repeatDifferentDoublePercentage;
	if (matchSame) template[template.length-1] += " *matchSame*";
	if (matchDifferent) template[template.length-1] += " *matchDifferent*";
	if (matchOnlyOneEver) template[template.length-1] += " *matchOnlyOneEver*";
	if (repeat) template[template.length-1] += " *repeat* " + repeatStart + " " + repeatEnd + " " + repeatInterval;
	if (hasMaster) template[template.length-1] += " *master* " + masterId;

	countId.length++;
	countId[countId.length-1] = 0;
	for (var countSubSection = 0; countSubSection < numChoices; countSubSection++) {
	    countId[countId.length-1]++;
	    if (recursiveUpdate() == -1) {
		template.length+=2;
		template[template.length-2] = "*leaf* " + writeId();
		template[template.length-1] = "*end_leaf* " + writeId();
	    }
	}
	countId.length--;
	template.length++;
	template[template.length-1] = "*end_" + myValue.substring(1,myValue.length) + " " + writeId() + " " + numChoices;
    }
    return 1;
}

/**
 * Updates the template by clearing it and calling recursiveUpdate.
 */
function updateTemplate() {
    template.length = 0;
    template = null;
    template = new Array();
    countId = new Array();
    countId.length = 1;
    countId[0] = 1;
    template.length++;
    template[template.length-1] = versionNumber + " gui version number"
    if (recursiveUpdate() == -1) alert("Error during recursiveUpdate()!  Is this template file correct?")
    loadTemplateIntoTextArea();
}

/**
 * Updates the template from the GUI.
 *
 * Then moves the GUI so that the given tag is at the top of the screen.
 */
function regenerate(tag) {
    updateTemplate();
    createGuiFromTemplate();
}

/**
 * Clears the template without affecting the gui.
 */
function clearTemplateNoReload() {
    template.length = 3;
    template[0] = versionNumber + " gui version number";
    template[1] = "*leaf* 1";
    template[2] = "*end_leaf* 1";
}

/**
 * Clears the template and then reloads the gui.
 */
function clearTemplateAndReloadAll() {
    clearTemplateNoReload();
    loadTemplateIntoTextArea();
    createGuiFromTemplate();
}


/**
 * Clears the template, reloads the gui, then moves the window to the GUI section.
 */
function clearTemplateAndReloadAllAndRecenter() {
    clearTemplateAndReloadAll();
    window.location.hash = "createTemplate";
}

							
/**
 * Loads the current template.
 */
function loadTemplate() {
    template.length = 0;
    template = null;
    template = new Array();
    var tempText = document.getElementById("templateText").value;
    while (tempText.charAt(tempText.length-1) == '\n') tempText = tempText.substring(0,tempText.length-1);
    template = tempText.split('\n');

    if (template[0].indexOf('\r')>-1) { //this is necessary because IE adds \r to the ends of the lines in the textarea
	for (var lineInTemplate = 0; lineInTemplate < template.length; lineInTemplate++) template[lineInTemplate] = template[lineInTemplate].slice(0, template[lineInTemplate].length-1);
    }

    createGuiFromTemplate();
    window.location.hash = "createTemplate";
}

/**
 * Increments a section's number of choices in the template.
 */
function incrementNumChoices(myParentId, increment) {
    var lineInTemplate = template.length;
    var splitLine;
    var parentIndex = lineInTemplate;
    var numChoicesString = '';
    var numChoicesInt = 0;
    var newNumChoices = '0';
    for (lineInTemplate = 0; lineInTemplate < template.length; lineInTemplate++) {
	splitLine = template[lineInTemplate].split(" ");
	if (splitLine.length > 2 && (splitLine[0] == "*random*" || splitLine[0] == "*constant*" || splitLine[0] == "*dependent*") && splitLine[1] == myParentId) {
	    parentIndex = lineInTemplate;
	    numChoicesString = splitLine[2];
	    numChoicesInt = parseInt(numChoicesString);
	    newNumChoices = numChoicesInt+increment;
	    template[lineInTemplate] = splitLine[0]+" "+splitLine[1]+" "+newNumChoices;
	    for (tempCount = 3; tempCount < splitLine.length; tempCount++) template[lineInTemplate] += " "+splitLine[tempCount];
	}
	if (splitLine.length > 2 && (splitLine[0] == "*end_random*" || splitLine[0] == "*end_constant*" || splitLine[0] == "*end_dependent*") && splitLine[1] == myParentId) {
	    template[lineInTemplate] = splitLine[0]+" "+splitLine[1]+" "+newNumChoices;
	    for (tempCount = 3; tempCount < splitLine.length; tempCount++) template[lineInTemplate] += " "+splitLine[tempCount];
	    break;
	}
    }
    return [parentIndex, numChoicesString, numChoicesInt, newNumChoices];
}

/**
 * Deletes a section from the template, then reloads the template and gui.
 */
function deleteSection(myId) {
    var parentIndex = template.length;
    var myParentId = myId.slice(0,myId.lastIndexOf('-'));
    var myCount = parseInt(myId.slice(myId.lastIndexOf('-')+1));
    var tempNum = 1+myCount;
    var nextId = myParentId + "-" + tempNum;
    var numChoicesString, numChoicesInt, newNumChoices, lineInTemplate, count;
    tempArray = incrementNumChoices(myParentId, -1);  //can't use [x, y, z] = function()  due to IE
    parentIndex = tempArray[0];
    numChoicesString = tempArray[1];
    numChoicesInt = tempArray[2];
    newNumChoices = tempArray[3];
    var offset = 0;
    for (lineInTemplate = parentIndex; lineInTemplate < template.length; lineInTemplate++) {
	splitLine = template[lineInTemplate].split(" ");
	if (splitLine[1] == myId) {
	    do {
		lineInTemplate++;
		offset++;
		splitLine = template[lineInTemplate].split(" ");
	    } while (splitLine[1] != myId)
	    lineInTemplate++;
	    offset++;
	}
	if (offset>0) template[lineInTemplate-offset] = template[lineInTemplate];        
    }
    if (offset>0) template.length -= offset;
    for (count = myCount+1; count <= numChoicesInt; count++) {
	var previousCount = count-1;
	var idWithCount = myParentId + "-" + count;
	for (lineInTemplate = parentIndex; lineInTemplate < template.length; lineInTemplate++) {
	    splitLine = template[lineInTemplate].split(" ");
	    if ((splitLine.length>1) && (splitLine[1].indexOf(idWithCount) == 0)) 	//I know that the id starts with the right string, but I have to check that "1-1" does not match "1-10" but does match "1-1-2"
		if ((splitLine[1].length == idWithCount.length) || (splitLine[1].charAt(idWithCount.length) == "-")) template[lineInTemplate] = template[lineInTemplate].replace(idWithCount, myParentId+"-"+previousCount);
	}
    }

    //if there is a dependent section, we may need to change the master
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	splitLine = template[lineInTemplate].split(" ");
	if (splitLine[0] == "*dependent*") {
	    indexOfLastDashNewID = myId.lastIndexOf("-");
	    if (splitLine[4].substr(0, indexOfLastDashNewID) == myId.substr(0, indexOfLastDashNewID)) { //do they have the same parent?
		//is the deleted section before the dependent's master section?
		splitMaster = splitLine[4].split("-");
		splitDeletedSection = myId.split("-");
		if (parseInt(splitMaster[splitDeletedSection.length-1]) > parseInt(splitDeletedSection[splitDeletedSection.length-1])) {
		    var newMaster = '';
		    for (tempIndex = 0; tempIndex < splitDeletedSection.length-1; tempIndex++) {
			newMaster = newMaster + splitMaster[tempIndex] + '-';
		    }
		    newMaster = newMaster + (parseInt(splitMaster[splitDeletedSection.length-1]) - 1);
		    //now add in the stuff after splitDeletedSection...
		    for (tempIndex = splitDeletedSection.length; tempIndex < splitMaster.length; tempIndex++) {
			newMaster = newMaster + '-' + splitMaster[tempIndex];
		    }
		    splitLine[4] = newMaster;
		    template[lineInTemplate] = splitLine[0];
		    for (tempIndex = 1; tempIndex < splitLine.length; tempIndex++) {
			template[lineInTemplate] = template[lineInTemplate] + " " + splitLine[tempIndex];
		    }
		}
	    }
	}
    }

    //is there a %next% section?  if so, we may need to update the section it points to
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	template[lineInTemplate] = updateNextSpecialText(template[lineInTemplate], myId, -1);
    }
    
    // Ok, I've removed the add & delete section buttons from the Dependent sections, but the user can still add & delete sections from the Random section that is depended upon.
    // I'm going to have to search through all the dependent sections, find any that depend upon this section, and update them similarly.
    var dependentSections = Array()
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	splitLine = template[lineInTemplate].split(" ");
	//Find all dependent sections, starting at the end of the template and working backwards.
	if ((splitLine[0] == "*dependent*") && (splitLine[4] == myParentId)) {
	    dependentSections.push(splitLine[1] + '-' + myCount.toString());
	}
    }
    for (var i = 0; i < dependentSections.length; i++) {
	deleteSection(dependentSections[i]);
    }
    
    loadTemplateIntoTextArea();
    createGuiFromTemplate();
}

/**
 * Helper function that updates the *next* special text when an id is deleted.
 */
function updateNextSpecialText(tempString, idBeingDeleted, increment) {
    if (tempString.indexOf("%next%") >= 0) {
	var lastIndexForNext = tempString.lastIndexOf("%next%");
	var tempStringAfterNext = tempString.substr(lastIndexForNext);
	var tempStringAfterNextSplit = tempStringAfterNext.split("%");
	var idFromNext = tempStringAfterNextSplit[2];
	var indexOfLastDashNewID = idBeingDeleted.lastIndexOf("-");
	if (idFromNext.substr(0, indexOfLastDashNewID) == idBeingDeleted.substr(0, indexOfLastDashNewID)) { //do they have the same parent?
	    //is the deleted section before the dependent's master section?
	    var splitMaster = idFromNext.split("-");
	    var splitDeletedSection = idBeingDeleted.split("-");
	    if (parseInt(splitMaster[splitDeletedSection.length-1]) >= parseInt(splitDeletedSection[splitDeletedSection.length-1])) {
		var newMaster = '';
		for (tempIndex = 0; tempIndex < splitDeletedSection.length-1; tempIndex++) {
		    newMaster = newMaster + splitMaster[tempIndex] + '-';
		}
		newSubsection = parseInt(splitMaster[splitDeletedSection.length-1]) + increment;
		if (newSubsection < 1)
		{
		    alert("Trying to update the %next% special text after a deletion, but got a subsection less than 1. Original: " + tempString);
		}
		newMaster = newMaster + newSubsection;
		//now add in the stuff after splitDeletedSection...
		for (tempIndex = splitDeletedSection.length; tempIndex < splitMaster.length; tempIndex++) {
		    newMaster = newMaster + '-' + splitMaster[tempIndex];
		}
		tempStringAfterNextSplit[2] = newMaster;
		var newText = tempStringAfterNextSplit[0];
		for (tempIndex = 1; tempIndex < tempStringAfterNextSplit.length; tempIndex++) {
		    newText = newText + "%" + tempStringAfterNextSplit[tempIndex];
		}
		return updateNextSpecialText(tempString.substr(0, lastIndexForNext), idBeingDeleted, increment) + newText;
	    }
	}
	return updateNextSpecialText(tempString.substr(0, lastIndexForNext), idBeingDeleted, increment) + tempStringAfterNext;
    }
    return tempString;
}

/**
 * Add a new section below another section.
 *
 * By changing the dropdown box and regenerating the template from the GUI.
 */
function addSectionBelow(myId) {
    var tempIdNum = document.getElementById("num"+myId);
    if (tempIdNum != null) tempIdNum.selectedIndex += 1;
    regenerate(myId+"-"+(tempIdNum.selectedIndex+1));
}

/**
 * Add a new section above an ID.
 *
 * By stepping through the template until we get to the right spot, adding a new leaf and then updating all the subsequent IDs.
 */
function addSectionAbove(myId) {
    var parentIndex = template.length;
    var myParentId = myId.slice(0,myId.lastIndexOf('-'));
    var myCount = parseInt(myId.slice(myId.lastIndexOf('-')+1));
    var tempNum = 1+myCount;
    var nextId = myParentId + "-" + tempNum;
    var lineInTemplate, splitLine, numChoicesString, numChoicesInt, numChoicesPlusOne, count, tempArray = new Array();
    tempArray = incrementNumChoices(myParentId, 1);  //can't use [x, y, z] = function()  due to IE
    parentIndex = tempArray[0];
    numChoicesString = tempArray[1];
    numChoicesInt = tempArray[2];
    numChoicesPlusOne = tempArray[3];

    //For each integer greater than my count, shift down the corresponding sub-point in the template.
    for (count = numChoicesInt; count >= myCount; count--) {
	var nextCount = count+1;
	var idWithCount = myParentId + "-" + count;
	for (lineInTemplate = parentIndex; lineInTemplate < template.length; lineInTemplate++) {
	    splitLine = template[lineInTemplate].split(" ");
	    if ((splitLine.length>1) && (splitLine[1].indexOf(idWithCount) == 0)) 	//I know that the id starts with the right string, but I have to check that "1-1" does not match "1-10" but does match "1-1-2"
		if ((splitLine[1].length == idWithCount.length) || (splitLine[1].charAt(idWithCount.length) == "-")) template[lineInTemplate] = template[lineInTemplate].replace(idWithCount, myParentId+"-"+nextCount);
	}
    }
    //If there is a dependent section, we may need to change its master ID because we added a section that shifted the master.
    //Search back from the end of the template.
    indexOfLastDashNewID = myId.lastIndexOf("-");
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	splitLine = template[lineInTemplate].split(" ");
	//Find all dependent sections.
	if (splitLine[0] == "*dependent*") {
	    if (splitLine[4].substr(0, indexOfLastDashNewID) == myId.substr(0, indexOfLastDashNewID)) { //Does the master of the dependent section we found have the same parent as where the new section is being added?
		splitMaster = splitLine[4].split("-");
		splitNewSection = myId.split("-");
		if (parseInt(splitMaster[splitNewSection.length-1]) >= parseInt(splitNewSection[splitNewSection.length-1])) { //is the new section before the dependent's master section?
		    var newMaster = '';
		    for (tempIndex = 0; tempIndex < splitNewSection.length-1; tempIndex++) {
			newMaster = newMaster + splitMaster[tempIndex] + '-';
		    }
		    newMaster = newMaster + (parseInt(splitMaster[splitNewSection.length-1]) + 1);
		    //now add in the stuff after splitNewSection...
		    for (tempIndex = splitNewSection.length; tempIndex < splitMaster.length; tempIndex++) {
			newMaster = newMaster + '-' + splitMaster[tempIndex];
		    }
		    splitLine[4] = newMaster;
		    template[lineInTemplate] = splitLine[0];
		    for (tempIndex = 1; tempIndex < splitLine.length; tempIndex++) {
			template[lineInTemplate] = template[lineInTemplate] + " " + splitLine[tempIndex];
		    }
		}
	    }
	}
    }

    //is there a %next% section?  if so, we may need to update the section it points to
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	template[lineInTemplate] = updateNextSpecialText(template[lineInTemplate], myId, 1);
    }

    template.length += 2;
    for (lineInTemplate = template.length-3; lineInTemplate > parentIndex; lineInTemplate--) {
	template[lineInTemplate+2] = template[lineInTemplate];
	splitLine = template[lineInTemplate].split(" ");
	if ((splitLine[0].indexOf("*end")!=0) && (splitLine[1] == nextId)) {
	    template[lineInTemplate] = "*leaf* "+myId;
	    template[lineInTemplate+1] = "*end_leaf* "+myId;
	    break;
	}
    }
    
    // Ok, I've removed the add & delete section buttons from the Dependent sections, but the user can still add & delete sections from the Random section that is depended upon.
    // With addSectionBelow I can just change the dropdown box and use the regenerate call to regenerate the template.
    // Here in addSectionAbove, I need to modify the template directly to add the blank Leaf section in the right place...and thus cannot use regenerate().
    // So I'm going to have to search through all the dependent sections, find any that depend upon this section, and update them similarly with new blank Leaf sections....by calling addSectionAbove.
    var dependentSections = Array()
    for (lineInTemplate = template.length-1; lineInTemplate > parentIndex; lineInTemplate--) {
	splitLine = template[lineInTemplate].split(" ");
	//Find all dependent sections, starting at the end of the template and working backwards.
	if ((splitLine[0] == "*dependent*") && (splitLine[4] == myParentId)) {
	    dependentSections.push(splitLine[1] + '-' + myCount.toString());
	}
    }
    for (var i = 0; i < dependentSections.length; i++) {
	addSectionAbove(dependentSections[i]);
    }
    
    loadTemplateIntoTextArea();
    createGuiFromTemplate();
}

/**
 * If the argument event is a keydown for a tab character, then insert a tab.
 *
 * If we don't catch these tab events, the browser will switch to the next UI element.
 */
function insertTab(event,obj) {
    var tabKeyCode = 9;
    if (event.which) // mozilla
        var keycode = event.which;
    else // ie
        var keycode = event.keyCode;
    if (keycode == tabKeyCode) {
        if (event.type == "keydown") {
            if (obj.setSelectionRange) {
                // mozilla
                var s = obj.selectionStart;
                var e = obj.selectionEnd;
                obj.value = obj.value.substring(0, s) + 
                    "\t" + obj.value.substr(e);
                obj.setSelectionRange(s + 1, s + 1);
                obj.focus();
            } else if (obj.createTextRange) {
                // ie
                document.selection.createRange().text="\t"
                obj.onblur = function() { this.focus(); this.onblur = null; };
            } else {
                // unsupported browsers
            }
        }
        if (event.returnValue) // ie ?
            event.returnValue = false;
        if (event.preventDefault) // dom
            event.preventDefault();
        return false; // should work in all browsers
    }
    return true;
}

/**
 * Loads example 1 into the template.
 */
function loadExample1() {
    var tempText = versionNumber + " gui version number\n*leaf* 1\nHello World\n*end_leaf* 1\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 2 into the template.
 */
function loadExample2() {
    var tempText = versionNumber + " gui version number\n*constant* 1 2\n*leaf* 1-1\nHello\n*end_leaf* 1-1\n*leaf* 1-2\nWorld\n*end_leaf* 1-2\n*end_constant* 1 2\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 3 into the template.
 */
function loadExample3() {
    var tempText = versionNumber + " gui version number\n*random* 1 2\n*leaf* 1-1\nHello\n*end_leaf* 1-1\n*leaf* 1-2\nWorld\n*end_leaf* 1-2\n*end_random* 1 2\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 4 into the template.
 */
function loadExample4() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*leaf* 1-1\nHello,\n*end_leaf* 1-1\n*random* 1-2 2\n*random* 1-2-1 2\n*leaf* 1-2-1-1\nJohn\n*end_leaf* 1-2-1-1\n*leaf* 1-2-1-2\nBob\n*end_leaf* 1-2-1-2\n*end_random* 1-2-1 2\n*leaf* 1-2-2\nMary\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\n,Bye\n*end_leaf* 1-3\n*end_constant* 1 3\n\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 5 into the template.
 */
function loadExample5() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*leaf* 1-1\nHello,\n*end_leaf* 1-1\n*random* 1-2 2 *repeat* 0 100 1\n*random* 1-2-1 2\n*leaf* 1-2-1-1\nJohn\n*end_leaf* 1-2-1-1\n*leaf* 1-2-1-2\nBob\n*end_leaf* 1-2-1-2\n*end_random* 1-2-1 2\n*leaf* 1-2-2\nMary\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\n,Bye\n*end_leaf* 1-3\n*end_constant* 1 3\n\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 6 into the template.
 */
function loadExample6() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*leaf* 1-1\nHello,\n*end_leaf* 1-1\n*random* 1-2 2 *matchSame*\n*random* 1-2-1 2\n*leaf* 1-2-1-1\nJohn\n*end_leaf* 1-2-1-1\n*leaf* 1-2-1-2\nBob\n*end_leaf* 1-2-1-2\n*end_random* 1-2-1 2\n*leaf* 1-2-2\nMary\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\n,Bye\n*end_leaf* 1-3\n*end_constant* 1 3\n\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 7 into the template.
 */
function loadExample7() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*leaf* 1-1\nHello,\n*end_leaf* 1-1\n*random* 1-2 2 *matchDifferent*\n*random* 1-2-1 2\n*leaf* 1-2-1-1\nJohn\n*end_leaf* 1-2-1-1\n*leaf* 1-2-1-2\nBob\n*end_leaf* 1-2-1-2\n*end_random* 1-2-1 2\n*leaf* 1-2-2\nMary\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\n,Bye\n*end_leaf* 1-3\n*end_constant* 1 3\n\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 8 into the template.
 */
function loadExample8() {
    var tempText = versionNumber + " gui version number\n*random* 1 4 *repeat* 0 100 1\n*leaf* 1-1\na\n*end_leaf* 1-1\n*leaf* 1-2\na\n*end_leaf* 1-2\n*leaf* 1-3\na\n*end_leaf* 1-3\n*leaf* 1-4\nb\n*end_leaf* 1-4\n*end_random* 1 4\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 9 into the template.
 */
function loadExample9() {
    var tempText = versionNumber + " gui version number\n*random* 1 2 *repeat* 1990 2000 2\n*leaf* 1-1\n%current% - %next%1% waiter. \n*end_leaf* 1-1\n*leaf* 1-2\n%current% - %next%1% chef. \n*end_leaf* 1-2\n*end_random* 1 2\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 10 into the template.
 */
function loadExample10() {
    var tempText = versionNumber + " gui version number\n*constant* 1 13\n*random* 1-1 2 *matchDifferent*\n*leaf* 1-1-1\nLinda Jones\n19 Ashland St #2\nSomerville, MA  02144\n(617) 499-7724\nljones344@hotmail.com\n\n*end_leaf* 1-1-1\n*leaf* 1-1-2\nMary E. Smith\n200 Summer St #3\nSomerville, MA  02144\n(617) 499-6971\nmsmith967@hotmail.com\n\n*end_leaf* 1-1-2\n*end_random* 1-1 2\n*leaf* 1-2\n\nObjective:\n\n*end_leaf* 1-2\n*random* 1-3 2 *matchDifferent*\n*leaf* 1-3-1\nTo obtain a position as a real estate agent.\n\n*end_leaf* 1-3-1\n*leaf* 1-3-2\nTo secure a real estate position.\n\n*end_leaf* 1-3-2\n*end_random* 1-3 2\n*leaf* 1-4\n\nEmployment History:\n\n*end_leaf* 1-4\n*random* 1-5 6 *repeatNoDoubles* *repeatDifferentDouble* 50 *matchSame* *repeat* 2003 1993 -1\n*leaf* 1-5-1\n*end_leaf* 1-5-1\n*random* 1-5-2 2 *repeatSame* *matchDifferent*\n*leaf* 1-5-2-1\n%current%-%next%1-5%	Cashier, Target, Everett, MA\n\n*end_leaf* 1-5-2-1\n*leaf* 1-5-2-2\n%current%-%next%1-5%	Cashier, Wal-Mart, Lynn, MA\n\n*end_leaf* 1-5-2-2\n*end_random* 1-5-2 2\n*random* 1-5-3 2 *repeatSame* *matchDifferent*\n*leaf* 1-5-3-1\n%current%-%next%1-5%	Administrative Assistant, Cambridge, MA\n		Typing, filing, telephone, copying, faxing, tracking referrals, reporting to central office (attendance/insurance data), petty cash, ordering supplies.\n\n*end_leaf* 1-5-3-1\n*leaf* 1-5-3-2\n%current%-%next%1-5%	Administrative assistant/receptionist, Cambridge, MA\n		Typing, faxing, telephone, ordering supplies, data entry, contacting insurance companies, reporting co-pays to Billing office.\n\n*end_leaf* 1-5-3-2\n*end_random* 1-5-3 2\n*random* 1-5-4 2 *repeatSame* *matchDifferent*\n*leaf* 1-5-4-1\n%current%-%next%1-5%	Receptionist	Somerville, MA\n\n*end_leaf* 1-5-4-1\n*leaf* 1-5-4-2\n%current%-%next%1-5%	Receptionist 	Cambridge, MA\n\n*end_leaf* 1-5-4-2\n*end_random* 1-5-4 2\n*random* 1-5-5 2 *repeatSame* *matchDifferent*\n*leaf* 1-5-5-1\n%current%-%next%1-5%	Personal Care Attendant	Barton's Angels	Northampton, MA\n		Traveling to clients home, assisting in clients' needs, (Dressing, cooking meals, showers, etc.) Bringing clients to various activities\n\n*end_leaf* 1-5-5-1\n*leaf* 1-5-5-2\n%current%-%next%1-5%	Personal Care attendant	Community Network Inc.	Holyoke, MA\n		Taking care of clients in their homes on an hourly basis or livein. Normal patient care, food preparation, assisting with bathing, helping dress, and light housekeeping.  Some transportation to events.\n\n*end_leaf* 1-5-5-2\n*end_random* 1-5-5 2\n*random* 1-5-6 2 *repeatSame* *matchDifferent*\n*leaf* 1-5-6-1\n%current%-%next%1-5%	Accounting Principals	Data Entry Clerk	Boston, MA\n		Entered timesheets and billing information.  Assisted expense department with filing.\n\n*end_leaf* 1-5-6-1\n*leaf* 1-5-6-2\n%current%-%next%1-5%	MetLife	Data Entry Clerk	Boston, MA\n		Inputting accounting entries and posting to the general ledger.  Filing, copying, sorting mail and cutting checks.\n\n*end_leaf* 1-5-6-2\n*end_random* 1-5-6 2\n*end_random* 1-5 6\n*leaf* 1-6\n\nEducation:\n\n*end_leaf* 1-6\n*random* 1-7 2 *matchDifferent*\n*leaf* 1-7-1\n2002-2003	Bremis School of Real Estate, Somerville, MA\n\n*end_leaf* 1-7-1\n*leaf* 1-7-2\n2002-2003	American Real Estate Academy; Waltham, MA\n\n*end_leaf* 1-7-2\n*end_random* 1-7 2\n*random* 1-8 2 *matchSame*\n*leaf* 1-8-1\n*end_leaf* 1-8-1\n*constant* 1-8-2 2\n*random* 1-8-2-1 2 *matchSame*\n*leaf* 1-8-2-1-1\n1996 		\n*end_leaf* 1-8-2-1-1\n*leaf* 1-8-2-1-2\n2002 		\n*end_leaf* 1-8-2-1-2\n*end_random* 1-8-2-1 2\n*random* 1-8-2-2 2 *matchDifferent*\n*leaf* 1-8-2-2-1\nDepartment of manpower & training, computer certificate\n\n*end_leaf* 1-8-2-2-1\n*leaf* 1-8-2-2-2\nComputer learning center certificate\n\n*end_leaf* 1-8-2-2-2\n*end_random* 1-8-2-2 2\n*end_constant* 1-8-2 2\n*end_random* 1-8 2\n*random* 1-9 3 *matchDifferent*\n*leaf* 1-9-1\n1955-1959	\n*end_leaf* 1-9-1\n*leaf* 1-9-2\n1962-1966	\n*end_leaf* 1-9-2\n*leaf* 1-9-3\n1967-1971	\n*end_leaf* 1-9-3\n*end_random* 1-9 3\n*random* 1-10 2 *matchDifferent*\n*leaf* 1-10-1\nHigh School Diploma, DeKalb High School; DeKalb, IL\n\n*end_leaf* 1-10-1\n*leaf* 1-10-2\nHigh School Diploma, Ames High School; Ames City, IA\n\n*end_leaf* 1-10-2\n*end_random* 1-10 2\n*leaf* 1-11\n\nLicenses:\n\n*end_leaf* 1-11\n*random* 1-12 2 *matchDifferent*\n*leaf* 1-12-1\nMassachusetts Licensed Real Estate Sales Person\n\n*end_leaf* 1-12-1\n*leaf* 1-12-2\nMassachusetts Real Estate License\n\n*end_leaf* 1-12-2\n*end_random* 1-12 2\n*leaf* 1-13\n\nReferences available on request.\n*end_leaf* 1-13\n*end_constant* 1 13\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 11 into the template.
 */
function loadExample11() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*random* 1-1 2\n*leaf* 1-1-1\nI want a job. \n*end_leaf* 1-1-1\n*leaf* 1-1-2\nDo you have an opening? \n*end_leaf* 1-1-2\n*end_random* 1-1 2\n*leaf* 1-2\nThank you, John. \n*end_leaf* 1-2\n*dependent* 1-3 2 *master* 1-1\n*leaf* 1-3-1\njohn111@me.com\n*end_leaf* 1-3-1\n*leaf* 1-3-2\njohn222@me.com\n*end_leaf* 1-3-2\n*end_dependent* 1-3 2\n*end_constant* 1 3\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 12 into the template.
 */
function loadExample12() {
    var tempText = versionNumber + " gui version number\n*constant* 1 5\n*leaf* 1-1\n<HTML>\n<HEAD>\n<style type='text/css'>\n.name {\n\n*end_leaf* 1-1\n*random* 1-2 2 *matchDifferent*\n*leaf* 1-2-1\n  color: black;\n  font-family: Arial, sans-serif;\n  font-size:30px\n\n*end_leaf* 1-2-1\n*leaf* 1-2-2\n  color: blue;\n  font-family: Times New Roman, serif;\n  font-size:20px\n\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\n}\n</style>\n</HEAD>\n<BODY>\n<p class='name'>\n*end_leaf* 1-3\n*random* 1-4 2 *matchDifferent*\n*leaf* 1-4-1\n<center>Janet Lane</center>\n*end_leaf* 1-4-1\n*leaf* 1-4-2\n<i>Bill Gunter</i>\n*end_leaf* 1-4-2\n*end_random* 1-4 2\n*leaf* 1-5\n</p>\n<p>Is looking for a job.\n<br><font size='-1'>Preferably <em>full</em>-time.</font>\n</p><ul><li>Hard worker.\n<li>Smart.\n<li>Have car will travel.</ul>\n<hr>\n<p align=right>Thank you.</p>\n</HTML>\n*end_leaf* 1-5\n*end_constant* 1 5\n";
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 13 into the template.
 */
function loadExample13() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*random* 1-1 2\n*leaf* 1-1-1\nMary\n\n*end_leaf* 1-1-1\n*leaf* 1-1-2\nBill\n\n*end_leaf* 1-1-2\n*end_random* 1-1 2\n*leaf* 1-2\n\nHistory:\n\n*end_leaf* 1-2\n*random* 1-3 3 *repeatNoDoubles* *repeatDifferentDouble* 50 *repeat* 2012 2006 -2\n*leaf* 1-3-1\n%next%1-3% - %current%	Target.\n\n*end_leaf* 1-3-1\n*leaf* 1-3-2\n%file%example_job_history_fragment.rtf%\n*end_leaf* 1-3-2\n*random* 1-3-3 2\n*leaf* 1-3-3-1\n%next%1-3% - %current%	Best Buy - cashier.\n\n*end_leaf* 1-3-3-1\n*leaf* 1-3-3-2\n%next%1-3% - %current%	Best Buy - customer service.\n\n*end_leaf* 1-3-3-2\n*end_random* 1-3-3 2\n*end_random* 1-3 3\n*end_constant* 1 3\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 14 into the template.
 */
function loadExample14() {
    var tempText = versionNumber + " gui version number\n*constant* 1 8\n*leaf* 1-1\n\\documentclass[letterpaper,12pt,oneside]{article}\n\n*end_leaf* 1-1\n*random* 1-2 4 *matchDifferent*\n*leaf* 1-2-1\n\\usepackage{tgbonum}\n\n*end_leaf* 1-2-1\n*leaf* 1-2-2\n\\usepackage{lmodern}\n\n*end_leaf* 1-2-2\n*leaf* 1-2-3\n\\usepackage{times}\n\n*end_leaf* 1-2-3\n*leaf* 1-2-4\n\\usepackage{courier}\n\n*end_leaf* 1-2-4\n*end_random* 1-2 4\n*leaf* 1-3\n\\title{\n*end_leaf* 1-3\n*random* 1-4 2\n*leaf* 1-4-1\nJim\n*end_leaf* 1-4-1\n*leaf* 1-4-2\nBill\n*end_leaf* 1-4-2\n*end_random* 1-4 2\n*leaf* 1-5\n}\n\\date{July 2012}\n\\begin{document}\n\\maketitle\n\n*end_leaf* 1-5\n*leaf* 1-6\n\\section{Job History}\nHere the job history is in an enumerated list.\n%comments can be added after a percent sign, TeX will not add them to the final document.\n\\begin{enumerate}\n*end_leaf* 1-6\n*random* 1-7 2\n*leaf* 1-7-1\n\\item Birdwatching\n\n*end_leaf* 1-7-1\n*leaf* 1-7-2\n\\item Counting sheep\n\n*end_leaf* 1-7-2\n*end_random* 1-7 2\n*leaf* 1-8\n\\end{enumerate}\n\n\n\\begin{small}\n\\emph{This text is small and emphasized.}\n\\end{small}\n\n\\end{document}\n*end_leaf* 1-8\n*end_constant* 1 8\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 15 into the template.
 */
function loadExample15() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*random* 1-1 2\n*leaf* 1-1-1\nRoger %store%first_name%rog-%\n*end_leaf* 1-1-1\n*leaf* 1-1-2\nMark %store%first_name%Mk.%\n*end_leaf* 1-1-2\n*end_random* 1-1 2\n*random* 1-2 2\n*leaf* 1-2-1\nWalker\n%store%last_name%walkabout%\n*end_leaf* 1-2-1\n*leaf* 1-2-2\nTannenbaum\n%store%last_name%tree%\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*leaf* 1-3\nRandomized addresses go here.\n\n%recall%first_name%%recall%last_name%@hotmail.com\n\n*end_leaf* 1-3\n*end_constant* 1 3\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 16 into the template.
 */
function loadExample16() {
    var tempText = versionNumber + " gui version number\n*random* 1 3 *nonUniformFirstSubPoint* 67 *repeat* 0 100 1\n*leaf* 1-1\na\n*end_leaf* 1-1\n*leaf* 1-2\nb\n*end_leaf* 1-2\n*leaf* 1-3\nc\n*end_leaf* 1-3\n*end_random* 1 3\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 17 into the template.
 */
function loadExample17() {
    var tempText = versionNumber + " gui version number\n*constant* 1 3\n*random* 1-1 2 *matchMaxSelectionsPerSubPoint* 2\n*leaf* 1-1-1\nSchool A\n*end_leaf* 1-1-1\n*leaf* 1-1-2\nSchool B\n*end_leaf* 1-1-2\n*end_random* 1-1 2\n*leaf* 1-2\n\n\n*end_leaf* 1-2\n*random* 1-3 4 *matchDifferent*\n*leaf* 1-3-1\nName 1\n*end_leaf* 1-3-1\n*leaf* 1-3-2\nName 2\n*end_leaf* 1-3-2\n*leaf* 1-3-3\nName 3\n*end_leaf* 1-3-3\n*leaf* 1-3-4\nName 4\n*end_leaf* 1-3-4\n*end_random* 1-3 4\n*end_constant* 1 3\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 18 into the template.
 */
function loadExample18() {
    var tempText = versionNumber + " gui version number\n*random* 1 4 *matchDifferent*\n*leaf* 1-1\nName 1\nold\n*end_leaf* 1-1\n*leaf* 1-2\nName 1\nyoung\n*end_leaf* 1-2\n*leaf* 1-3\nName 2\nold\n*end_leaf* 1-3\n*leaf* 1-4\nName 2\nyoung\n*end_leaf* 1-4\n*end_random* 1 4\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}

/**
 * Loads example 19 into the template.
 */
function loadExample19() {
    var tempText = versionNumber + " gui version number\n*constant* 1 6\n*random* 1-1 5 *hide* *matchDifferent*\n*leaf* 1-1-1\n*end_leaf* 1-1-1\n*leaf* 1-1-2\n*end_leaf* 1-1-2\n*leaf* 1-1-3\n*end_leaf* 1-1-3\n*leaf* 1-1-4\n*end_leaf* 1-1-4\n*leaf* 1-1-5\n*end_leaf* 1-1-5\n*end_random* 1-1 5\n*random* 1-2 5 *hide* *matchDifferent*\n*leaf* 1-2-1\n*end_leaf* 1-2-1\n*leaf* 1-2-2\n*end_leaf* 1-2-2\n*leaf* 1-2-3\n*end_leaf* 1-2-3\n*leaf* 1-2-4\n*end_leaf* 1-2-4\n*leaf* 1-2-5\n*end_leaf* 1-2-5\n*end_random* 1-2 5\n*random* 1-3 6 *hide* *matchDifferent*\n*leaf* 1-3-1\n*end_leaf* 1-3-1\n*leaf* 1-3-2\n*end_leaf* 1-3-2\n*leaf* 1-3-3\n*end_leaf* 1-3-3\n*leaf* 1-3-4\n*end_leaf* 1-3-4\n*leaf* 1-3-5\n*end_leaf* 1-3-5\n*leaf* 1-3-6\n*end_leaf* 1-3-6\n*end_random* 1-3 6\n*random* 1-4 6 *hide* *matchDifferent*\n*leaf* 1-4-1\n*end_leaf* 1-4-1\n*leaf* 1-4-2\n*end_leaf* 1-4-2\n*leaf* 1-4-3\n*end_leaf* 1-4-3\n*leaf* 1-4-4\n*end_leaf* 1-4-4\n*leaf* 1-4-5\n*end_leaf* 1-4-5\n*leaf* 1-4-6\n*end_leaf* 1-4-6\n*end_random* 1-4 6\n*random* 1-5 4 *matchDifferent*\n*constant* 1-5-1 3\n*dependent* 1-5-1-1 5 *master* 1-1\n*leaf* 1-5-1-1-1\nnorth1\n*end_leaf* 1-5-1-1-1\n*leaf* 1-5-1-1-2\nnorth2\n*end_leaf* 1-5-1-1-2\n*leaf* 1-5-1-1-3\nnorth3\n*end_leaf* 1-5-1-1-3\n*leaf* 1-5-1-1-4\nnorth4\n*end_leaf* 1-5-1-1-4\n*leaf* 1-5-1-1-5\nnorth5\n*end_leaf* 1-5-1-1-5\n*end_dependent* 1-5-1-1 5\n*leaf* 1-5-1-2\n\n\n*end_leaf* 1-5-1-2\n*dependent* 1-5-1-3 6 *master* 1-3\n*leaf* 1-5-1-3-1\ncollege1\n*end_leaf* 1-5-1-3-1\n*leaf* 1-5-1-3-2\ncollege2\n*end_leaf* 1-5-1-3-2\n*leaf* 1-5-1-3-3\ncollege3\n*end_leaf* 1-5-1-3-3\n*leaf* 1-5-1-3-4\ncollege4\n*end_leaf* 1-5-1-3-4\n*leaf* 1-5-1-3-5\ncollege5\n*end_leaf* 1-5-1-3-5\n*leaf* 1-5-1-3-6\ncollege6\n*end_leaf* 1-5-1-3-6\n*end_dependent* 1-5-1-3 6\n*end_constant* 1-5-1 3\n*constant* 1-5-2 3\n*dependent* 1-5-2-1 5 *master* 1-1\n*leaf* 1-5-2-1-1\nnorth1\n*end_leaf* 1-5-2-1-1\n*leaf* 1-5-2-1-2\nnorth2\n*end_leaf* 1-5-2-1-2\n*leaf* 1-5-2-1-3\nnorth3\n*end_leaf* 1-5-2-1-3\n*leaf* 1-5-2-1-4\nnorth4\n*end_leaf* 1-5-2-1-4\n*leaf* 1-5-2-1-5\nnorth5\n*end_leaf* 1-5-2-1-5\n*end_dependent* 1-5-2-1 5\n*leaf* 1-5-2-2\n\n\n*end_leaf* 1-5-2-2\n*dependent* 1-5-2-3 6 *master* 1-4\n*leaf* 1-5-2-3-1\nhigh school1\n*end_leaf* 1-5-2-3-1\n*leaf* 1-5-2-3-2\nhigh school2\n*end_leaf* 1-5-2-3-2\n*leaf* 1-5-2-3-3\nhigh school3\n*end_leaf* 1-5-2-3-3\n*leaf* 1-5-2-3-4\nhigh school4\n*end_leaf* 1-5-2-3-4\n*leaf* 1-5-2-3-5\nhigh school5\n*end_leaf* 1-5-2-3-5\n*leaf* 1-5-2-3-6\nhigh school6\n*end_leaf* 1-5-2-3-6\n*end_dependent* 1-5-2-3 6\n*end_constant* 1-5-2 3\n*constant* 1-5-3 3\n*dependent* 1-5-3-1 5 *master* 1-2\n*leaf* 1-5-3-1-1\nsouth1\n*end_leaf* 1-5-3-1-1\n*leaf* 1-5-3-1-2\nsouth2\n*end_leaf* 1-5-3-1-2\n*leaf* 1-5-3-1-3\nsouth3\n*end_leaf* 1-5-3-1-3\n*leaf* 1-5-3-1-4\nsouth4\n*end_leaf* 1-5-3-1-4\n*leaf* 1-5-3-1-5\nsouth5\n*end_leaf* 1-5-3-1-5\n*end_dependent* 1-5-3-1 5\n*leaf* 1-5-3-2\n\n\n*end_leaf* 1-5-3-2\n*dependent* 1-5-3-3 6 *master* 1-3\n*leaf* 1-5-3-3-1\ncollege1\n*end_leaf* 1-5-3-3-1\n*leaf* 1-5-3-3-2\ncollege2\n*end_leaf* 1-5-3-3-2\n*leaf* 1-5-3-3-3\ncollege3\n*end_leaf* 1-5-3-3-3\n*leaf* 1-5-3-3-4\ncollege4\n*end_leaf* 1-5-3-3-4\n*leaf* 1-5-3-3-5\ncollege5\n*end_leaf* 1-5-3-3-5\n*leaf* 1-5-3-3-6\ncollege6\n*end_leaf* 1-5-3-3-6\n*end_dependent* 1-5-3-3 6\n*end_constant* 1-5-3 3\n*constant* 1-5-4 3\n*dependent* 1-5-4-1 5 *master* 1-2\n*leaf* 1-5-4-1-1\nsouth1\n*end_leaf* 1-5-4-1-1\n*leaf* 1-5-4-1-2\nsouth2\n*end_leaf* 1-5-4-1-2\n*leaf* 1-5-4-1-3\nsouth3\n*end_leaf* 1-5-4-1-3\n*leaf* 1-5-4-1-4\nsouth4\n*end_leaf* 1-5-4-1-4\n*leaf* 1-5-4-1-5\nsouth5\n*end_leaf* 1-5-4-1-5\n*end_dependent* 1-5-4-1 5\n*leaf* 1-5-4-2\n\n\n*end_leaf* 1-5-4-2\n*dependent* 1-5-4-3 6 *master* 1-4\n*leaf* 1-5-4-3-1\nhigh school1\n*end_leaf* 1-5-4-3-1\n*leaf* 1-5-4-3-2\nhigh school2\n*end_leaf* 1-5-4-3-2\n*leaf* 1-5-4-3-3\nhigh school3\n*end_leaf* 1-5-4-3-3\n*leaf* 1-5-4-3-4\nhigh school4\n*end_leaf* 1-5-4-3-4\n*leaf* 1-5-4-3-5\nhigh school5\n*end_leaf* 1-5-4-3-5\n*leaf* 1-5-4-3-6\nhigh school6\n*end_leaf* 1-5-4-3-6\n*end_dependent* 1-5-4-3 6\n*end_constant* 1-5-4 3\n*end_random* 1-5 4\n*constant* 1-6 2\n*leaf* 1-6-1\n\nSomething not matched with area/education: \n*end_leaf* 1-6-1\n*random* 1-6-2 4 *matchDifferent*\n*leaf* 1-6-2-1\n1\n*end_leaf* 1-6-2-1\n*leaf* 1-6-2-2\n2\n*end_leaf* 1-6-2-2\n*leaf* 1-6-2-3\n3\n*end_leaf* 1-6-2-3\n*leaf* 1-6-2-4\n4\n*end_leaf* 1-6-2-4\n*end_random* 1-6-2 4\n*end_constant* 1-6 2\n*end_constant* 1 6\n"
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}


/**
 * Loads example 20 into the template.
 */
function loadExample20() {
    var tempText = versionNumber + ' gui version number\n*random* 1 1 *matchSame*\n*leaf* 1-1\nIf the resume contains one or more Random sections that are matching:\n\n    %numberofresumesperbatch% will be replaced by the number of resumes in the batch.\n    %resume% and %resumepadded% will be replaced by the number of this resume in the current batch (e.g., for a batch of 3 this will be replaced with 1 in the first resume and 3 in the last resume of the batch.)\n    %numberofbatches% will be replaced by the number of batches being generated.\n    %batch% and %batchpadded% will be replaced by 1 for the first batch, and n for the nth batch generated.\n    %totalnumberofresumes% will be replaced by the result of (%numberofbatches% times %numberofresumesperbatch%).\n    %resumecountoverbatches% and %resumecountoverbatchespadded% will be replaced by the result of (((%batch% - 1) times %numberofresumesperbatch%) plus %resume%), so it starts at 1 and increments with each resume generated within and across batches.\n\nIf the resume does not contain any matching sections, then each resume is treated as a separate batch:\n\n    %numberofresumesperbatch% will be replaced by 1.\n    %resume% and %resumepadded% will be replaced by 1.\n    %numberofbatches% will be replaced by the number of resumes being generated from the template (i.e., the number entered at the prompt "How many resumes should be generated?").\n    %batch% and %batchpadded% will be replaced by the number of this resume in the current generation of resumes (e.g., if 6 resumes are being created this will be replaced with 1 in the first resume and 6 in the last resume.)\n    %totalnumberofresumes% will be replaced by the same value as %numberofbatches%.\n    %resumecountoverbatches% and %resumecountoverbatchespadded% will be replaced by the same value as %batch%.\n*end_leaf* 1-1\n*end_random* 1 1\n'
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}


/**
 * Loads example 21 into the template.
 */
function loadExample21() {
    var tempText = versionNumber + ' gui version number\n*constant* 1 7\n*leaf* 1-1\nShopping list\n\n	Non-dairy:\n-eggs\n-carrots\n%store%header%%%store%postsection%%\n\n*end_leaf* 1-1\n*random* 1-2 2\n*leaf* 1-2-1\n%store%header%	Dairy:\\n%%store%postsection%\\n%\n*end_leaf* 1-2-1\n*leaf* 1-2-2\n*end_leaf* 1-2-2\n*end_random* 1-2 2\n*random* 1-3 2\n*leaf* 1-3-1\n%store%header%	Dairy:\\n%%store%postsection%\\n%\n*end_leaf* 1-3-1\n*leaf* 1-3-2\n*end_leaf* 1-3-2\n*end_random* 1-3 2\n*leaf* 1-4\n%recall%header%\n*end_leaf* 1-4\n*dependent* 1-5 2 *master* 1-2\n*leaf* 1-5-1\n-milk\n\n*end_leaf* 1-5-1\n*leaf* 1-5-2\n*end_leaf* 1-5-2\n*end_dependent* 1-5 2\n*dependent* 1-6 2 *master* 1-3\n*leaf* 1-6-1\n-ice cream\n\n*end_leaf* 1-6-1\n*leaf* 1-6-2\n*end_leaf* 1-6-2\n*end_dependent* 1-6 2\n*leaf* 1-7\n%recall%postsection%	Other stuff:\n-pet food\n\n*end_leaf* 1-7\n*end_constant* 1 7\n'
    document.getElementById("templateText").value = tempText;
    loadTemplate();
}
			

/**
 * Selects all the template text.
 */
function selectAll(id) {
    document.getElementById("templateText").focus();
    document.getElementById("templateText").select();
}


/**
 * This parses a copy of the template, recursively, and creates the GUI.
 */
function parseTemplateCopy(templateCopy, repeatParent, parentHidden, canDeleteMe, parentTypes, lineNumber, guiText) {
    var tempSplit = new Array();
    tempSplit = templateCopy[lineNumber[0]].split(" ");
    var myText = tempSplit[0];
    if ((myText != "*leaf*") && (myText != "*random*") && (myText != "*constant*") && (myText != "*dependent*")) {
	if (templateCopy[lineNumber[0]] == "") templateCopy[lineNumber[0]] = "a blank line";

	guiText.push("</hidden><p style='background-color:yellow;'>Error! The template text (in the right frame) is malformed.<br>Could not find a start tag (e.g., *random*).  Instead, got: "+templateCopy[lineNumber[0]]+"</p><p style='background-color:yellow;'>Review the template text in the right-hand frame and make sure that the lines that start with *constant*, *random*, and *dependent* all correctly identify the number of their subsections.  For example, a line that says '*constant* 2-4-1 5' must have 5 subsections.</p>");
	return -1;
    }
    var myLabel = tempSplit[1];
    parentTypes[myLabel] = myText;
    var hidden = false;
    if ((tempSplit.length > 3) && (tempSplit[3] == "*hide*")) hidden = true;
    var hideMe = hidden || parentHidden;
    if (hidden && !parentHidden) guiText.push('<p><li><a name="' + myLabel + '" id="' + myLabel + '">'+myLabel+'</a>');
    if (parentHidden) guiText.push('<a name="' + myLabel + '" id="' + myLabel + '"></a>');
    if (hideMe) {
	guiText.push('<hidden>');
    } else {
	guiText.push('<p><li>');
	if (myLabel != "1") {
	    var parentLabel = myLabel.split('-').slice(0, -1).join('-');
	    if (parentTypes[parentLabel] != "*dependent*") guiText.push('<input type="button" value="Add section here" onClick="parent.addSectionAbove(\'' +myLabel+ '\');"><br>');
	}
	guiText.push('<a name="' + myLabel + '" id="' + myLabel + '">'+myLabel+'</a>');
    }
    guiText.push(' <select id="type' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');">');
    if (myText == "*leaf*") {
	var copyOfText = "";
	guiText.push('<option SELECTED value="*leaf*">Leaf</option>');
	guiText.push('<option value="*constant*">Constant</option>');
	guiText.push('<option value="*random*">Random</option>');
	guiText.push('<option value="*dependent*">Dependent</option>');
	guiText.push('</select>');
	lineNumber[0]++;
	if (canDeleteMe && (parentTypes[parentLabel] != "*dependent*")) guiText.push(' <input type="button" value="Delete this section" onClick="parent.deleteSection(\'' +myLabel+ '\');">');
	var tempLineNumber = lineNumber[0];
	while ((tempLineNumber < templateCopy.length) && (templateCopy[tempLineNumber].indexOf("*end_leaf*")<0) && (templateCopy[tempLineNumber].indexOf(myLabel)<0)) {
	    tempLineNumber++;
	}
	textarea_height = tempLineNumber - lineNumber[0];
	guiText.push('<br><TEXTAREA id="leaf' + myLabel + '" onchange="parent.updateTemplate();" cols="100" rows="' + textarea_height + '" wrap="off" onkeydown="return parent.insertTab(event,this);">');
	var doOnce = 0;
	while ((templateCopy[lineNumber[0]].indexOf("*end_leaf*")<0) && (templateCopy[lineNumber[0]].indexOf(myLabel)<0)) {
	    if (doOnce == 0) {
		doOnce = 1;
		if (templateCopy[lineNumber[0]] == '') {
		    guiText.push("\n");
		    if (hideMe) copyOfText += "<br>";
		}
	    } else {
		guiText.push("\n");
		if (hideMe) copyOfText += "<br>";
	    }
	    guiText.push(templateCopy[lineNumber[0]]);
	    if (hideMe) copyOfText += templateCopy[lineNumber[0]];
	    lineNumber[0]++;
	    if (lineNumber[0] >= templateCopy.length) {
		guiText.push("</TEXTAREA></hidden><p style='background-color:yellow;'>Error! The template text (in the right frame) is malformed.<br>Could not find *end_leaf* " + myLabel + "<br>Review the template text in the right-hand frame and make sure that the lines that start with *constant*, *random*, and *dependent* all have the correct number (following the section label) for the number of their subsections.  For example, a line that says '*constant* 2-4-1 5' must have 5 subsections.</p>");
		return -3;
	    }
	}
	guiText.push('</TEXTAREA>');
	if (hideMe) {
	    copyOfText = copyOfText.replace(/ /g,'&nbsp;');
	    if (copyOfText == "") copyOfText = "<emptySub>&nbsp;</emptySub>";
	    guiText.push('</hidden>' + copyOfText);  //I would use <pre> here, but that breaks randomStart and randomSub
	}
	lineNumber[0]++;
	return 1;
    }

    if ((myText == "*random*") || (myText == "*dependent*") || (myText == "*constant*")) {
	var myNumChoices = tempSplit[2];
	guiText.push('<option value="*leaf*">Leaf</option>');
	guiText.push('<option');
	if (myText=="*constant*") {
	    guiText.push(' SELECTED');
	}
	guiText.push(' value="*constant*">Constant</option>');
	guiText.push('<option');
	if (myText=="*random*") {
	    guiText.push(' SELECTED');
	}
	guiText.push(' value="*random*">Random</option>');
	guiText.push('<option');
	if (myText=="*dependent*") {
	    guiText.push(' SELECTED');
	}
	guiText.push(' value="*dependent*">Dependent</option>');
	guiText.push('</select>');

	if (myText == "*random*") {
	    var repeat = false;
	    var repeatSame = false;
	    var repeatNever = false;
	    var repeatNoDoubles = false;
	    var repeatDifferentDouble = false;
	    var matchSame = false;
	    var matchDifferent = false;
	    var matchOnlyOneEver = false;
	    var minimumNumberOfEntries = 0;
	    var maximumNumberOfEntries = 0;
	    var matchMaxSelectionsPerSubPoint = false;
	    var nonUniformFirstSubPoint = false;
	    for (countSplit = 3; countSplit < tempSplit.length; countSplit++) {
		if ((tempSplit[countSplit] == "*repeat*") && (tempSplit.length > countSplit+3)) {
		    repeat = true
		    var repeatStart = tempSplit[countSplit+1]
		    var repeatEnd = tempSplit[countSplit+2]
		    var repeatInterval = tempSplit[countSplit+3]
		}
		else if (tempSplit[countSplit] == "*repeatSame*") repeatSame = true
		else if (tempSplit[countSplit] == "*repeatNever*") repeatNever = true
		else if (tempSplit[countSplit] == "*repeatNoDoubles*") repeatNoDoubles = true
		else if ((tempSplit[countSplit] == "*repeatDifferentDouble*") && (tempSplit.length > countSplit +1)) {
		    repeatDifferentDouble = true
		    var repeatDifferentDoublePercentage = tempSplit[countSplit+1]
		}
		else if ((tempSplit[countSplit] == "*minimumNumberOfEntries*") && (tempSplit.length > countSplit +1)) {
		    minimumNumberOfEntries = tempSplit[countSplit+1]
		}
		else if ((tempSplit[countSplit] == "*maximumNumberOfEntries*") && (tempSplit.length > countSplit +1)) {
		    maximumNumberOfEntries = tempSplit[countSplit+1]
		}
		else if (tempSplit[countSplit] == "*matchSame*") matchSame = true;
		else if (tempSplit[countSplit] == "*matchDifferent*") matchDifferent = true;
		else if (tempSplit[countSplit] == "*matchOnlyOneEver*") matchOnlyOneEver = true;
		else if ((tempSplit[countSplit] == "*matchMaxSelectionsPerSubPoint*") && (tempSplit.length > countSplit +1)) {
		    matchMaxSelectionsPerSubPoint = true;
		    var maxSelectionsPerSubPointInteger = tempSplit[countSplit+1]
		}
		else if ((tempSplit[countSplit] == "*nonUniformFirstSubPoint*") && (tempSplit.length > countSplit +1)) {
		    nonUniformFirstSubPoint = true;
		    var nonUniformFirstSubPointPercentage = tempSplit[countSplit+1]
		}
	    }
	    if ((matchSame && matchDifferent) || (matchSame && matchOnlyOneEver) || (matchSame && matchMaxSelectionsPerSubPoint) || (matchDifferent && matchOnlyOneEver) || (matchDifferent && matchMaxSelectionsPerSubPoint) || (matchDifferent && matchMaxSelectionsPerSubPoint)) {
		alert("Cannot have more than one match requirement (e.g., MatchSame, MatchDifferent) for Random section " + myLabel);
		matchSame = true
		matchDifferent = false;
		matchOnlyOneEver = false;
		matchMaxSelectionsPerSubPoint = false;
	    }
	}

	if ((myText == "*random*") || (myText == "*constant*")) {
	    guiText.push('<select id="num' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');"');
	    //    if ((myText == "*random*") && (matchDifferent)) guiText.push(' disabled');
	    guiText.push('>');
	    for (var countNums = 1; countNums < 200; countNums++) {
		guiText.push('<option');
		if (myNumChoices == countNums) {
		    guiText.push(' SELECTED');
		}
		guiText.push(' value="' + countNums + '">' + countNums + '</option>');
	    }
	    guiText.push('</select>');
	}
	if (myText == "*dependent*") {
	    //are there any random sections?
	    var foundAtLeastOneRandom = false;
	    for (var tempLineNumber = 0; tempLineNumber < templateCopy.length; tempLineNumber++) {
		var tempSplitToFindRandoms = new Array();
		tempSplitToFindRandoms = templateCopy[tempLineNumber].split(" ");
		if (tempSplitToFindRandoms[1] == myLabel) break;
		if (tempSplitToFindRandoms[0] == "*random*") {
		    foundAtLeastOneRandom = true;
		    break;
		}
	    }
	    if (foundAtLeastOneRandom) {
		var myMasterId = "";
		for (countSplit = 3; countSplit < tempSplit.length-1; countSplit++) {
		    if (tempSplit[countSplit] == "*master*") {
			myMasterId = tempSplit[countSplit + 1];
			break;
		    }
		}
		guiText.push(' on section labeled <select id="master' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');">');
		for (var tempLineNumber = 0; tempLineNumber < templateCopy.length; tempLineNumber++) {
		    var tempSplitToFindRandoms = new Array();
		    tempSplitToFindRandoms = templateCopy[tempLineNumber].split(" ");
		    if (tempSplitToFindRandoms[1] == myLabel) break;
		    if (tempSplitToFindRandoms[0] == "*random*") {
			foundAtLeastOneRandom = true;
			thisRandomId = tempSplitToFindRandoms[1];
			guiText.push('<option');
			if (myMasterId == thisRandomId) guiText.push(' SELECTED');
			guiText.push(' value="' + thisRandomId + '">' + thisRandomId + '</option>');
		    }
		}
		guiText.push('</select>');
	    } else guiText.push(' but there are no random sections upon which it can depend.');
	}
	if (hidden && !parentHidden) guiText.push('</hidden>');
	guiText.push(' <input id="hidden' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
	if (hidden) guiText.push(' checked');
	guiText.push('>Hide</input> ')
	if (hidden && !parentHidden) guiText.push('<br><hidden>');
	if (myText == "*random*") {
	    guiText.push(' <input id="nonUniformFirstSubPoint' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
	    if (nonUniformFirstSubPoint) guiText.push(' checked')
	    guiText.push('>First sub-point percentage')
	    if (nonUniformFirstSubPoint) guiText.push(':')
	    guiText.push('</input>')
	    if (nonUniformFirstSubPoint) guiText.push('...Percent (0 to 100):<input id="nonUniformFirstSubPointPercentage' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');" size="2" value="'+nonUniformFirstSubPointPercentage+'"></input>%');

	    if (matchSame || matchDifferent || matchOnlyOneEver || matchMaxSelectionsPerSubPoint) {
		guiText.push(' <input id="matched' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');" checked>Matched:</input>')
		guiText.push('<input id="matchDifferent' + myLabel + '" name="match' + myLabel + '" type="radio" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (matchDifferent) guiText.push(' checked')
		guiText.push('>MatchDifferent</input>, <input id="matchSame' + myLabel + '" name="match' + myLabel + '" type="radio" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (matchSame) guiText.push(' checked')
		guiText.push('>MatchSame</input>, <input id="matchOnlyOneEver' + myLabel + '" name="match' + myLabel + '" type="radio" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (matchOnlyOneEver) guiText.push(' checked')
		guiText.push('>MatchOnlyOneEver</input>, <input id="matchMaxSelectionsPerSubPoint' + myLabel + '" name="match' + myLabel + '" type="radio" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (matchMaxSelectionsPerSubPoint) guiText.push(' checked')
		guiText.push('>MatchMaxSelectionsPerSubPoint')
		if (matchMaxSelectionsPerSubPoint) guiText.push(':')
		guiText.push('</input>')
		if (matchMaxSelectionsPerSubPoint) guiText.push('<input id="maxSelectionsPerSubPointInteger' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');" size="2" value="'+maxSelectionsPerSubPointInteger+'"></input>');
	    }
	    else guiText.push(' <input id="matched' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');">Matched</input>')

	    guiText.push('<br><input id="repeat' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
	    if (repeat) guiText.push(' checked')
	    guiText.push('>Repeat</input>')
	    if (repeat) {
		guiText.push('...Start:<input id="repeatStart' + myLabel + '" onchange="parent.updateTemplate();" size="5" value="'+repeatStart+'"></input>');
		guiText.push(' End:<input id="repeatEnd' + myLabel + '" onchange="parent.updateTemplate();" size="5" value="'+repeatEnd+'"></input>');
		guiText.push(' Interval:<input id="repeatInterval' + myLabel + '" onchange="parent.updateTemplate();" size="5" value="'+repeatInterval+'"></input>');
		guiText.push(' <input id="repeatNoDoubles' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"');
		if (repeatNoDoubles) guiText.push(' checked');
		guiText.push('>Do not print doubles</input>');
		if ((repeatNoDoubles) && (!repeatNever) && (!repeatSame)) {
		    guiText.push(', Minimum # of entries:<input id="minimumNumberOfEntries' + myLabel + '" onchange="parent.updateTemplate();" size="2" value="'+minimumNumberOfEntries+'"></input>');
		    guiText.push(', Maximum # of entries:<input id="maximumNumberOfEntries' + myLabel + '" onchange="parent.updateTemplate();" size="2" value="'+maximumNumberOfEntries+'"></input>');
		}
	    }
	    if (repeat || repeatParent) {
		guiText.push(' <input id="repeatSame' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (repeatSame) guiText.push(' checked')
		guiText.push('>Same when repeat</input>')
		guiText.push(' <input id="repeatNever' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (repeatNever) guiText.push(' checked')
		guiText.push('>Always different when repeat</input>')
		guiText.push(' <input id="repeatDifferentDouble' + myLabel + '" type="checkbox" onClick="parent.regenerate(\'' +myLabel+ '\');"')
		if (repeatDifferentDouble) guiText.push(' checked')
		guiText.push('>Non-uniform chance for immediate repeat</input>')
		if (repeatDifferentDouble) guiText.push('...Percent (0 to 100):<input id="repeatDifferentDoublePercentage' + myLabel + '" onchange="parent.regenerate(\'' +myLabel+ '\');" size="2" value="'+repeatDifferentDoublePercentage+'"></input>%');
	    }
	}
	if (canDeleteMe) guiText.push(' <input type="button" value="Delete this section" onClick="parent.deleteSection(\'' +myLabel+ '\');">');
	if (hideMe) {
	    guiText.push('</hidden>');
	    if (myText == "*random*") guiText.push('<randomStart>');
	    if (myText == "*dependent*") guiText.push('<dependentStart>');
	} else guiText.push('<ul>');
	lineNumber[0]++;

	for (var countNums = 0; countNums < myNumChoices; countNums++) {
	    if ((myText == "*random*") && (hideMe)) guiText.push('<randomSub>');
	    if ((myText == "*dependent*") && (hideMe)) guiText.push('<dependentSub>');
	    returnVal = parseTemplateCopy(templateCopy, repeat || repeatParent, hideMe, myNumChoices>1, parentTypes, lineNumber, guiText);
	    if ((myText == "*random*") && (hideMe)) guiText.push('</randomSub>');
	    if ((myText == "*dependent*") && (hideMe)) guiText.push('</dependentSub>');
	    if (returnVal < 0) return returnVal;
	}
	if (hideMe) {
	    if (myText == "*random*") guiText.push('</randomStart>');
	    if (myText == "*dependent*") guiText.push('</dependentStart>');
	} else {
	    if (myText == "*dependent*") {
		guiText.push('</ul>');
	    } else {
		guiText.push('<br><input type="button" value="Add section here" onClick="parent.addSectionBelow(\'' +myLabel+ '\');"></ul>');
	    }
	}

	if (templateCopy[lineNumber[0]].indexOf("*end_" + myText.substring(1,myText.length) + " " + myLabel) < 0) {
	    guiText.push("</hidden><p style='background-color:yellow;'>Error! Template text (in right frame) is malformed.<br>Could not find <br>*end_" + myText.substring(1,myText.length) + " " + myLabel + "<br>Review the template text in the frame to the right and make sure that each *leaf*, *constast*, *random*, and *dependent* section has a corresponding *end_leaf*, *end_constant*, etc., line, and that the section labels match.  So if there is a line '*leaf* 1-1', then further down in the template text there must be the line '*end_leaf* 1-1'.</p>");
	    return -2;
	}
	lineNumber[0]++;
	return 1;
    }
    // I was expecting to find a start tag (*leaf*, *random*, etc)...but I didn't.  So there's a problem.
    return -1;
}


/**
 * Returns a string naming the type of the argument.
 */
function toType(obj) {
    return ({}).toString.call(obj).match(/\s([a-zA-Z]+)/)[1].toLowerCase()
}


/**
 * Writes the template global variable into the sidebar textarea.
 */
function loadTemplateIntoTextArea() {
    document.getElementById('templateText').value = template.join('\n');
}


/**
 * Creates the gui from the template by calling parseTemplateCopy.
 */
function createGuiFromTemplate() {
    if (typeof template === "undefined") {
	document.getElementById('gui').innerHTML = "<p style='background-color:yellow;'>Error! Unable to load template; template array is undefined.</p>";
    } else {
	guiText = ['<p><ul>'];
	lineNumber = [1]; // use an array so we can change the lineNumber from inside parseTemplateCopy
	while (lineNumber < template.length) {
	    if (parseTemplateCopy(template, false, false, false, {}, lineNumber, guiText) < 0) break;
	    lineNumber[0]++;
	}
	guiText.push('</ul>');
	document.getElementById('gui').innerHTML = guiText.join('');
    }
}


/**
 * On-load, load the template
 */
function bodyOnloadFunction() {
    clearTemplateAndReloadAll();
}

</SCRIPT>

</HEAD>
<body onload="bodyOnloadFunction();">
<div id="content">
<div id="leftSide">

<h1>Resume Randomizer Template Generator.  <span style="font-size:50%">Version 30</span></h1>
<p>This webpage generates templates for the Resume Randomizer program.
<br>Firefox, Chrome, Safari, Internet Explorer, and Microsoft Edge should all work.  Regardless of browser, you may be required to enable "active content" or "allow blocked content".
<p>Jump to: <a href="#basic">Basic Use</a>, <a href="#explanation">Explanation</a>, <a href="#createTemplate">Template Creation</a>, <a href="#files">Files</a>, <a href="#examples">Examples</a>, <a href="#advanced">Advanced Use</a>, <a href="#changelog">Changelog</a>.

<hr>
<h2><a name="basic">Basic Use</a></h2>
<ul>
<li>To generate a template, use the drop down boxes in the middle of this page ("create templates here") to select a type (one of 'Constant', 'Random', 'Dependent', or 'Leaf') for each point in the outline, entering text for each 'Leaf' point.  See the examples below for illustrations of the use of the program.
<li>To <b>save</b> a template, copy the text in the frame to the right and paste into a file on your computer.  That file must be in the same folder as the Resume Randomizer program and its name must end with ".rtf" (no quotes), which stands for resume template file.  Use Notepad, Emacs, Vi, or some other editor that does not store extra information in the file.  Do not use Microsoft Word or Wordpad, because the resume-randomizer.exe program cannot handle extra information (e.g., formatting, or version info for the editor) added to the resume template file.
<li>To <b>create</b> resumes* from a template, if you are on Windows you can run (double-click) the Resume Randomizer program, "resume-randomizer.exe".  Alternatively, on Windows, macOS, or Linux you can install <a href="https://www.anaconda.com/download/#download">Python 3</a> and use it to run "resume-randomizer.py". Either way the resume randomizer program will then ask which template file it should use to create resumes.
<li>To <b>load</b> a template into this webpage for changes at a later date: 1) delete the text in the frame to the right, 2) copy the text from a previously created template file, 3) paste that text into the right-hand frame's text box, 4) then press the button "Load this template" which will update the gui to represent the loaded template.
<li>Pressing the "Clear template" button in the right-hand frame will reset the template so that there is only one point, a 'Leaf'.
<li>Pressing the "Select all" button in the right-hand frame will select the text, making it easier to copy or delete.
</ul>
* Note that the Resume Randomizer program is not limited to creating resumes.  It combines randomly selected text snippets into a text file, and can therefore be used to create any text document, including but not limited to cover letters, webpages, source code for programs, or book chapters.  Since the program was designed for resume audits, this webpage refers to the outputs as resumes.
<p>Advanced usage is explained below.

<hr>
<h2><a name="explanation">Explanation</a></h2>
<p>This webpage generates templates which are used by the Resume Randomizer program, "resume-randomizer.exe", to create resumes with randomized characteristics.  It is possible to create templates without using this webpage, but this webpage makes the process easier by reducing potential for errors and providing a graphical user interface.  See the included "README.md" file for an overview, as well as: Lahey, Joanna and Beasley, Ryan A., Computerizing Audit Studies (July 1, 2007). Available at SSRN: <a style="white-space:nowrap;" href="http://ssrn.com/abstract=1001038">http://ssrn.com/abstract=1001038</a> or <a style="white-space:nowrap;" href="http://dx.doi.org/10.2139/ssrn.1001038">http://dx.doi.org/10.2139/ssrn.1001038</a>.
<p>When creating resumes, the program starts at the top point in the template's outline (which has the label '1').  When it encounters an outline point with the 'Constant' type, it moves to each of the sub-points in the order listed.  When the program encounters an outline point with the 'Random' type, it moves to only one of the sub-points (chosen randomly with equal likelihood by default).  When it encounters an outline point with the 'Dependent' type, it must depend on a specific 'Random' section earlier in the template; the 'Dependent' section always chooses the same sub-point as the 'Random' section on which it depends.  When the program encounters an outline point with the 'Leaf' type, it writes any text in that 'Leaf' to the resume file.  Note that outline points labeled 'Constant' and 'Random' have drop-down boxes to select the number of sub-points. See the "Examples" section for demonstrations of randomized characteristics in resumes.
    <p>The program produces four files for each resume, plus a single codebook file and a "collated" data file.  All the created files are plain-text.  The resume itself ends in ".doc".  The other three files created for each resume (ending in ".sav", ".txt", and ".csv") are data files that contain the choices made for each 'Random' and 'Dependent' section in the generation of that resume from the template.  Each of these three files contains sufficient information to reconstruct the resume from the template, and the data in all of the csv files are concatenated into the single collated csv file.  The single codebook file (ends in ".xls") matches the numbers in those data files with the actual text that would be placed in the resumes.  These files are discussed in more detail in the section "Output of resume-randomizer.exe".

<hr><h2><a name="createTemplate">Create templates here:</a></h2>
<div id='gui'>
</div>
<SCRIPT type="text/javascript">
</SCRIPT>

<hr>
    <h2><a name="files">Files</a></h2>
    <h3>Included example files</h3>
    <p>Four example templates are included with the Resume Randomizer program.  The first is named "example_cover_letter_template.rtf" and generates cover letters for a matched pairs study, such that the two cover letters contain different but functionally equivalent text.  The second is named "example_resume_template.rtf" and generates resumes as if for a matched pair study on the effects of high school graduation date on the probability of interview callbacks.  Note that this latter template is the same as Example 10 (below).  The third is named "example_resume_template_with_fragments.rtf" and is discussed in Example 13 (below) and the section on file fragments.  To create text files (cover letters or resumes, respectively) from these template files, run the Resume Randomizer program as explained in the Basic Use section above, and follow the prompts that will ask which template to use and how many cover letters or resumes to create.

  <h3>Language and file encoding</h3> The fourth example template is "example_cyrillic_template.rtf", and demonstrates non-English resume generation.  The software allows for various languages and file encodings.  Chinese (simplified) and Cyrillic text have been tested.  The program will attempt to load any template or fragment file using the system default encoding, which should be sufficient for most use cases.  If that fails, the program will try to "guess" the correct encoding.  Any Unicode (e.g., utf-8) encoded file should always be handled correctly.  If any problems arise, try saving the templates and fragment files using a Unicode (e.g., utf-8) encoding, and contact us if you need additional help.
    <p>All line endings will be converted to the system-specific version (e.g., CR+LF on Windows), so a template created on Windows can be used on Linux or macOS, or vice versa.</p>

<h3>Output of resume-randomizer.exe</h3>
<p>The resume-randomizer.exe program produces a codebook file, a collated data file, the "resumes", and three data files for each resume.  All the created files are plain-text.  The resume itself ends in ".doc".  Since the file is plaintext, it does not need to be opened by Microsoft Word (or Open Office), but can be loaded into any text editor or webbrowser.  Its extension can be changed to ".txt" or ".html" (or ".tex"), to make it easier to load in a different program.</p>
<p>The single codebook file ends in ".xls".  It is a tab-delimited file.  Each line contains the text for a Leaf, along with the parent section's label (e.g., 1-3-8), and the number of this Leaf in that parent section.  The codebook is meant to assist interpretation of the ".csv" files, which contain the number of the Leaf selected for each Random or Dependent section in each iteration.  The codebook is particularly useful when the template contains "file fragments" because the text from the fragments are collated into the codebook along with the parent section label and the Leaf number.</p>
<ul>
<li>If the program finds one or more existing codebook files for the template file, it will check to see if the last-modified codebook is correct for the current template.  If there is a previous codebook and it is correct, no new codebook is created.  If the program does not find a codebook file, or the codebook file is not correct, a new codebook file will be created.  The program will not overwrite previous codebook files (the new codebook's filename will contain the lowest available integer).
<li>Keeping multiple codebooks for the same template file may be necessary if 1) the same template filename is used to generate resumes before and after changes to the template itself, and 2) the experimenter wants to analyze data from both the pre-edit and post-edit sets of resumes.  Specifically any changes to the template that would affect the data stored in the codebook could necessitate multiple codebooks (some template changes will not affect the Leafs and so will not alter the codebook).  In that case:
<ul>
<li>The experimenter should keep copies of both the template and the codebook from before and after those edits.  The experiment must also keep track of which resumes correspond to which template file and codebook file.
<li>One simple approach to avoiding this issue is to always change the template's filename whenever it is edited, and ensure that the new filename is unique (e.g., a version number in the filename).  In this manner only one codebook file will be created for each template file.
</ul>
</ul>
<p>A single "collated" csv file is also created that contains all the random choices made by the 'Random' and 'Dependent' sections.  So just that one collated csv file is necessary for data analysis.  A new collated csv file is created each time the executable generates a new set of batches of resumes.  The collated csv files should not overwrite each other because each contains the date and time of creation in its filename.
  <ul>
    <li>The one complication with putting all of the csv data into one file is how to order the variables, since not all Random sections are entered for each resume.  Our solution has been to sort the variable names, which generally is useful (e.g., v1-1 comes before v1-2, as it does in the template) but can be confusing when a Repeating Random section counts down (has a negative step value) and uses "Do not print doubles."  See Example 10 for instance: the collated csv file will list the variable v1_5_iter1994 before v1_5_iter1995, even though the program actually made the 1994 random selection after the 1995 random selection...and therefore if both v1_5_iter1994 and v1_5_iter1995 were 3 then there will be a v1_5_iter1995_3 in which the sub-choice was made, but there will not be a v1_5_iter1994_3 because the v1_5 section is "Do not print doubles" so the sub-section will not even be entered for iteration 1994 since it is immediately repeating the 1995 selection. If you look at the individual csv files you will see that the variables therein are ordered as the decisions were made.
  </ul>
<p>For each ".doc" file, the program also generates files ending in ".sav", ".txt", and ".csv" containing the choices made for each 'Random' and 'Dependent' section in the generation of that resume from the template.  These data files are meant to assist analysis of experimental results with respect to resume text.  Each of these files contains sufficient information to reconstruct the resume from the template...but it is generally easier to use the single collated csv file.
<small>
<ul>
  <li>The ".csv" file is meant to make it easier to load the data into an analysis program (e.g., Stata).  It consists of comma-separated text, with one line containing variable names (e.g., the identification of the section making a choice), and a second line with the choices made by each Random and Dependent section, for each iteration. (Note that the Dependent section choices <em>should</em> be duplicates of the Random sections they depend upon.)
    <ul><li>Beware that the data saved to the ".csv" files is in a different format than the data saved to the ".txt" and ".doc" files.  First, the variable names are not the same as the section labels, due to the inclusion of the iteration.  Second, the text "v" is prepended onto the point labels.  For example, if section 1-2 is Random and repeating with start 10, end 14, interval 2, then the variable names would contain v1-2-iter10, v1-2-iter12, and v1-2-iter14.  Third, the choices on the second line run from 1 through n, where n is the number of subsections.</ul>
  <li>The ".txt" file contains just the filename for the resume and then a tab-delimited list of the choices made by the program in creating the resume.  The choices are numbers 0 through n-1 where n is the number of subsections.  So if the program generated a resume by randomly always choosing the first option in each Random section, the ".txt" file would contain the filename followed by zeros, all separated by tabs.  Parsing this information requires understanding the structure of the template.
  <li>The ".sav" file contains several lines of explanatory text describing how the resume was generated, and then a description of how to read the rest of the file.  The rest of the file consists of pairs of lines.  The first line in each pair is the description (or tag) of the section that required a choice.  The second line is the choice that was made (a number 0 through n-1 where n is the number of subsections).  The inclusion of the section information makes the information in this format easier to parse.
</ul>
</small>
</p>

<hr>
<h2><a name="examples">Examples</a></h2>
<h4>Example 1, basic operation</h4><input type="button" value="Load Example 1" onClick="parent.loadExample1()">
Set the first drop down box above to 'Leaf'.  There should only be one text box.  Enter "Hello World" into that text box.  Save the template as described above and run the Resume Randomizer program.  From the menu that appears, choose the template file that was just saved.  When asked how many resumes to make, answer '2'.  Two files ending in ".doc" will be created, each containing just the text "Hello World".  The names for those two text files will start with the name of the template file, then the date (in Year-Month-Day-Hour-Minute-Second format), and then some underscores separating numbers that distinguish the resumes created at the same time (described in more detail in another example below).
<h4>Example 2, multiple text blocks</h4><input type="button" value="Load Example 2" onClick="parent.loadExample2()">
Set the first drop down box to 'Constant'.  A second drop down box will be right next to the one you just changed.  This second drop down box specifies the number of sub-points under this point in the outline.  Set that second drop down box to '2'.  There are now two sub-points with labels '1-1' and '1-2'.  Set the drop down box for each of them to 'Leaf'.  In the text box for '1-1', the upper 'Leaf', enter "Hello".  In the text box for '1-2', the bottom 'Leaf', enter "World".  As in the first example: save the template, run the Resume Randomizer program and create a few resumes from this template.  The generated resumes should all contain the text, "HelloWorld".  Spaces or blank lines can be entered in the text boxes of the template to put spaces or blank lines between the words in the resume files.
<h4>Example 3, random selections</h4><input type="button" value="Load Example 3" onClick="parent.loadExample3()">
Set the template up as for Example 2, then set the first drop down box to 'Random'.  As above, save the template, run the Resume Randomizer program, and generate some resumes for this template.  Some of the resumes will contain the text "Hello" and the others will contain the text "World".  If a large enough number of resumes are generated, half of them should contain each result.
<h4>Example 4, nested random selections and non-uniform probabilities</h4><input type="button" value="Load Example 4" onClick="parent.loadExample4()">
Set the point labeled '1' (the first outline point) to 'Constant' with 3 sub-points (set in the drop-down box just to the right of the type).  Set the '1-1' point to a 'Leaf' with the text "Hello,".  Set the '1-2' point to 'Random' with 2 sub-points.  Set '1-2-1' to 'Random' with 2 sub-points, each a 'Leaf'.  For the text of '1-2-1-1' enter "John".  For the text of '1-2-1-2' enter "Bob".  Set '1-2-2' to a 'Leaf' with the text "Mary".  Finally, set '1-3' to a 'Leaf' with the text ",Bye".  As above, save the template, run the Resume Randomizer program, and generate some resumes for this template.  Approximately half of the resumes will contain "Hello,Mary,Bye", one quarter will say "Hello,John,Bye", and one quarter will say "Hello,Bob,Bye".
<h4>Example 5, repeated random selections</h4><input type="button" value="Load Example 5" onClick="parent.loadExample5()">
Set the template up as for Example 4.  Then for '1-2' check the 'Repeat' checkbox (described in detail below).  Set the 'start' value to 0, the 'end' value to 100, and the 'interval' value to 1.  Generate some resumes.  Now each resume will contain 100 names, each randomly chosen.  Again, "Mary" will appear about half the time, "John" one-quarter of the time, and "Bob" the remainder.
<h4>Example 6, matched random selections with same choice</h4><input type="button" value="Load Example 6" onClick="parent.loadExample6()">
Set the template up as for Example 4 again.  Then for '1-2' check the 'Matched' checkbox (described in detail below).  Select the 'Match Same' radio button.  As above, save the template, and run the Resume Randomizer program.  This time, after asking "How many?" the program will ask how many resumes to match.  If the first question is answered that the program should match '3' resumes per batch, and then the program is told to generate '5' batches, a total of 15 resumes will be created.  The names of the resume files will end in "_X_YofZ.doc" where X is the number of the batch (1 through 5 in this example), Y is the number of the resume within the batch (1 through 3 in this example), and Z is the total number of resumes in each batch (3 in this example).  Each of the resumes in a batch (i.e., with the same X value in the filename) will have chosen the same choice for the first Random section (whether or not the name should be Mary).  If the first resume in a batch contains Mary, then all resumes in the batch will contain Mary.  If the first resume contains a name other than Mary, then none of the resumes in the batch will contain Mary, but since the John/Bob Random section (1-2-1) is not set to MatchSame they will each independently randomly select either John or Bob.  Each batch of matched resumes chooses Mary vs non-Mary independently from all other batches.
<h4>Example 7, matched random selections with different choices</h4><input type="button" value="Load Example 7" onClick="parent.loadExample7()">
Set the template up as for Example 6.  Then select the 'Match Different' radio button for point '1-2' (instead of 'Match Same').  Each resume in a batch will now be forced to choose a different choice than all the other resumes in that batch.  Since there are only two choices for that 'Random' point, the generated batches cannot be larger than 2 resumes without generating an error.  Generate some resumes matched in pairs, and observe that in each pair one of the resumes will contain "Mary" and the other will contain either "John" or "Bob".
<h4>Example 8, repeated random selections and non-uniform probablities without nested sections</h4><input type="button" value="Load Example 8" onClick="parent.loadExample8()">
Set the first point to 'Random' that repeats 100 times and has 4 sub-points, each a 'Leaf'.  Set the text for the first three 'Leaf's to "a" and the text for the fourth 'Leaf' to "b".  Generate some resumes.  In each resume, "a" should appear three times as often as "b".
<h4>Example 9, using special text while repeating, and "do not print doubles"</h4><input type="button" value="Load Example 9" onClick="parent.loadExample9()">
Set the first point to 'Random' with two sub-points, each a 'Leaf'.  Make the 'Random' repeat with start 1990, end 2000, interval 2, to signify that jobs will be chosen every two years starting in 1990 and stopping before 2000.  Set the text for the '1-1' 'Leaf' to "%current% - %next%1% waiter. ", and the text for the '1-2' 'Leaf' to "%current% - %next%1% chef. ".  Generate some resumes and note how the special text inside each 'Leaf' is replaced with the values from the counter.  If the 'Random' point was also marked "Do not print doubles", a possible output would be "1990 - 1994 waiter. 1994 - 1996 chef. 1996 - 2000 waiter."
<h4>Example 10, typical resume</h4><input type="button" value="Load Example 10" onClick="parent.loadExample10()">
Open the "example_resume_template.rtf" file provided with the Resume Randomizer program.  Copy the text inside that file and paste it into the text box on the right, replacing any text already there.  Press the "Load this template" button.
<br>You may then wish to check the "Hide" checkbox next to the topmost section, to see just the text and structure of the template.
<br>This template creates resumes for one of two people, "Linda" and "Mary", which are chosen using the '1-1' 'Random' point.  That point is set to Match Different, so that when creating a matched pair, one resume will get the text for "Linda" and the other will get the text for "Mary".  The '1-5' 'Random' point contains all of the characteristics for the work history.  The history repeats for 10 years from 2003 to 1993.  That point is set to Match Same so that both resumes in the matched pair will take the same sub-point each year.  The first sub-point, '1-5-1' is a 'Leaf' with no text in the text box.  So when this choice is picked, nothing is added to the resume for that year.  The other sub-points, '1-5-2' through '1-5-6' are all 'Random' points with two sub-points each.  If the program chooses '1-5-2', then it will choose between '1-5-2-1' and '1-5-2-2', which may be considered functionally equivalent jobs (cashiers at large stores).  Furthermore, the points labeled '1-5-2' through '1-5-6' are all set to Match Different, so that the "Linda" resume will get one of the two functionally equivalent jobs, and the "Mary" resume will get the other functionally equivalent job.
<br>Notice that the 'Leaf' points for the work history contain special text (explained below) to print the years worked.  Also note the use of "Do not print doubles" (explained below) to prevent printing job text twice in a row.  Generate a few resumes from this template and compare the results to the template.
<br>This template uses the "Non-uniform chance for immediate repeat" setting to specify the probability that the same work history will be chosen that was picked the previous year.
<h4>Example 11, choosing the same subsections using dependent sections</h4><input type="button" value="Load Example 11" onClick="parent.loadExample11()">
Set the first point to 'Constant' with three subsections.  Set the first subsection to 'Random' with two subsections, both of type 'Leaf'.  Set the text for those 'Leaf's to "I want a job. " and "Do you have an opening? ".  Set section '1-2' to a 'Leaf' with the text, "Thank you, John. ".  Set section '1-3' to 'Dependent'.  It will automatically select the first (and currently only) 'Random' section ('1-1') on which to depend.  Set sections '1-3-1' and '1-3-2' to 'Leaf's with "john111@me.com" and "john222@me.com" respectively.  Generate some resumes and see how "I want a job. " is always followed by "john111@me.com", while "Do you have an opening? " is always followed by "john222@me.com".
<h4>Example 12, formatting resumes using templates that generate HTML</h4><input type="button" value="Load Example 12" onClick="parent.loadExample12()">
In this example, you can see how the program can be used to generate HTML, including using Cascading Style Sheets (CSS) to set formatting, along with various HTML tags for italics, horizontal rule, etc.
<h4>Example 13, file fragments</h4><input type="button" value="Load Example 13" onClick="parent.loadExample13()">
In this example, section 1-3-2 demonstrates the special text for a file fragment, %file%XXXXX%.  File fragments allow a file containing multiple Leafs to be substituted into a template.  See further explanation in the "Advanced Use" section. Specifically, this uses the fragment file distributed as an example with the resume randomizer, example_job_history_fragment.rtf, so make sure that file is in the same folder when running the resume randomizer on this template.
<h4>Example 14, TeX for formatting</h4><input type="button" value="Load Example 14" onClick="parent.loadExample14()">
Similar to Example 12, by having the template generate valid TeX files the resulting resumes can contain formatting.  Note that the .doc files will have to be compiled using (for example) LaTeX or pdfTeX.  This approach makes it easy to generate pdfs of all the resumes.  If the resumes need to be images (e.g., jpeg, tiff, png) then ImageMagick can batch convert the PDF or postscript files.
<h4>Example 15, template-created variables, %store% and %recall%</h4><input type="button" value="Load Example 15" onClick="parent.loadExample15()">
In this example, the email address in Leaf 1-3 is based on the random selection of the first name (Random section 1-1), and the random selection of the last name (Random section 1-2).  It would be possible to "nest" the random section(s) for the last name inside the random section for the first name, but that would require duplicating the random selection of the last name in two places.  Instead, each leaf that contains a first name stores a template-created variable "first_name", and each leaf that contains a last name stores a variable "last_name".  Then, the email is created by recalling those two variables and adding the name of the email service provider.
<h4>Example 16, first sub-point percentage</h4><input type="button" value="Load Example 16" onClick="parent.loadExample16()">
In this example, the first subpoint of a random section is selected with a specific probability.  If you create a resume you will see that 2/3rds of the letters are "a", and the remaining sub-points ("b" and "c") are chosen with uniform probability. By nesting random sections, each with a "first sub-point percentage", it is possible to exactly specify probabilities for each possible leaf.
<h4>Example 17, matched max selections per sub-point</h4><input type="button" value="Load Example 17" onClick="parent.loadExample17()">
In this example, the schools in the sub-points of the first random section will not be selected more than twice each, while the names in the sub-points of the second random section will each only be selected once. If you create a batch of 4 resume you will see that exactly half of the resumes have "School A" while the other half have "School B".  If you create a batch of 3 resumes, two of them will have the same school, and the third resume will have the other school.  If you attempt to create a batch of more than 4 resumes, the Resume Randomizer program will fail with an error because the first Random section only has two sub-points, and each can only be selected up to twice, for a maximum of 4 selections.
<h4>Example 18, 2x2 the simple way</h4><input type="button" value="Load Example 18" onClick="parent.loadExample18()">
If you want a 2x2 design (or any size of factorial study), the simple way is to create a Random section that is the size of the multiple of the factors.  So a 2x2 on name and age becomes a Random section with four subpoints. Generally the Random section will be MatchDifferent and 4 resumes will be matched per batch, so that there is exactly 1 of each type of resume in the batch.
<h4>Example 19, factorial design using the same pool of characteristics</h4><input type="button" value="Load Example 19" onClick="parent.loadExample19()">
If you want a factorial design in which the characteristics are "matched" across the treatments, then the template must have all the resumes pass through the same Random section for those characteristics.
In this example, the Random MatchDifferent point 1-5 will make sure that there is always 1 north-college, 1 north-high school, 1 south-college, and 1 south-high school.  To make sure that the north resumes have different names, the names in the two north sub-points (1-5-1-1 and 1-5-2-1) are both dependent on an earlier Random section (1-1) that is set to MatchDifferent.  Ditto for the south names.  So all resumes pick which north name they would use, and which south name they would use, prior to determining whether they should use the north or south name.  Ditto for the college & high school names.
<h4>Example 20, batch and resume number special text</h4><input type="button" value="Load Example 20" onClick="parent.loadExample20()">
This example demonstrates the special texts that are replaced by resume and batch counts.  It is currently set for matching, but by unchecking the Matched button it can also be used to test non-matched behavior.
<h4>Example 21, header only if some body text</h4><input type="button" value="Load Example 21" onClick="parent.loadExample21()">
Sometimes a resume may or may not have text in a certain section, and the resume should only have a header for that section if there is some text to go under the header.  This example shows how to make the header text depend on the existence of at least one entry of body text.

<hr>
<h2><a name="advanced">Advanced Use</a></h2>
<h3>Formatting resumes:</h3>If the resumes must have formatting (e.g., fonts, italics, right justification, text color, etc.) there are at least four methods of applying that formatting:
<ol>
  <li>Our recommendation is to create templates that generate TeX and then use pdfTeX/LaTeX/MiKTeX to create the resumes from those TeX files.  See Example 14 above.
  <li>Second, formatting can be done manually, e.g., open each resume in Word and format them individually.  If many resumes are being created such formatting could take a significant amount of time.
  <li>Third, templates can be created that generate HTML, as in Example 12 above.  The resumes will still end in ".doc", and can be opened with a webbrowser, or Microsoft Word, or Apache OpenOffice Writer.  Then, any formatting can be contained in the HTML, and in fact, the formatting can be randomized just like any other aspect of the resumes.
    <ul><li>Generating HTML (and therefore webpages) significantly increases the capabilities of the resulting "resumes", allowing for tables, lists, images, hyperlinks, ads, etc.  It is even possible to put javascript code into the template, which will be run when the resumes are opened by a web browser (or when the user click a button or moves the mouse over a certain area), so it is possible to use this program to put programs into your HTML "resumes".
    </ul>
  <li>Fourth, it can be done programmatically, e.g., with a macro in Microsoft Word.  Creation of such macros may take careful thought, since the resumes can vary in length and content.  It may be necessary to add special "tags" (combinations of letters and numbers) to the template, so that the macro can find the starts and ends of different sections or words that you want to have different formatting.  Removal of those tags can be part of the macro itself.
</ol>

<h3>"Hide" setting:</h3>In order to reduce clutter in the GUI above, outline points marked "Hide" do not display any of the controls (i.e., buttons, drop-down boxes, text entry areas) for themselves or their subpoints.  Instead, 'Random' and 'Dependent' points are displayed with a black border inside of which their subpoints are displayed, each surrounded by a grey border. 'Constant' and 'Leaf' points do not create borders.  This setting has no effect on generation of resume files; it just changes the way the GUI looks.

<h3>Non-equal likelihood:</h3>When choosing between two (or more) options for characteristics (e.g., "Linda" vs. "Mary"), the experimenter may not want each option to be chosen an equal amount of the time.  Four methods exist for choosing characteristics so that they appear with non-uniform probability.
<ol>
<li>Nest random sections (Example 4 above).
<li>Copy that characteristic, so that the 'Random' point has n chances to choose the copied characteristic (where n is the total number of copies) (Example 8 above).
<li>Use the setting called "First sub-point percentage" (Example 16 above). That setting specifies the percentage that the first sub-point in the Random section will be chosen, and is only considered after all other settings are addressed (i.e., it does not supersede or conflict with any other setting such as "Non-uniform chance for immediate repeat"). If the first sub-point is not chosen (either randomly, or due to another setting like "Always different when repeat") then the remaining sub-points each have a uniform probability of being chosen. If a file fragment (see below) is loaded as the Random section's first sub-point, the first leaf in the fragment will be the one to which the specific probability is applied. To get a specific probability for each of several leaf texts, simply nest Random sections each with the "First sub-point percentage" setting.
<li>Use the setting called "Non-uniform chance for immediate repeat" which is described below in the section marked "Repeating" and does not affect the chance that a characteristic will be initially chosen (Example 10 above).
</ol>

<h3>Matched "pairs":</h3>This option allows the experiment to create matched resumes based on experimenter-defined matches.  There are four ways resumes can be matched.  These options are exclusive to each other. Matching is not limited to pairs of resumes; it can be applied to batches of 2 or more resumes (batches up to 100 have been tested.)
<ol>
<li>The first way is that any of the 'Random' points can be set to "Match Same", in which case the matched resume files will all choose the same characteristic <em>for the same iteration</em> (Examples 6&10 above).
<li>The second way is that any of the 'Random' points can be set to "Match Different", in which case the resume files will be generated such that no two files will choose the identical characteristic (Examples 7&10 above) <em>for the same iteration.</em> Make sure that any point marked "Match Different" contains at least one characteristic per matched resume. If there is no repeating involved, this is "selection without replacement."
<li>The third way is that any of the 'Random' points can be set to "Match Only One Ever", in which case only one resume file can ever contain each of the sub-sections.  The difference between "Match Different" and "Match Only One Ever" is that if there is a repeating random section (see below) with only two sub-sections and you generate a matched pair of resumes, then for "Match Only One Ever" only one resume will ever have the first sub-section (and the other resume will have the other sub-section), while with "Match Different" they can alternate so that in each iteration of the repetition the first resume could get either of the sub-sections (with its matched pair being forced to take the other sub-section).
<li>The fourth way is that any of the 'Random' points can be set to "Match Max Selections Per Sub Point", which allows the specification of the maximum number of times that each sub-point/characteristic in a Random section will be chosen in a batch. The Resume Randomizer program will count the number of times each sub-point is selected within a batch (counting each iteration separately), and will stop selecting a sub-point once that sub-point's count reaches the maximum. One use-case is to generate X number of resumes from a template with a Random section with two sub-points, where exactly X/2 resumes must use the first sub-point and the others must use the second sub-point.   See Example 17.
<ul>
<li>This functionality can be somewhat duplicated by generating X/2 resumes each from two completely separate templates, but because those would be separate batches there would not be any matching enforced between the two sets, e.g., "selection without replacement", MatchOnlyOneEver.  Using this MatchMaxSelectionsPerSubPoint setting enables the user to limit the number of selections and keep the "selection without replacement" and other features that are limited to a single template.
<li>Since it is much harder to programmatically specify a *minimum* number of selections because of the way the program works, that control has not been implemented.  However, if you know the number of times a Random section will be entered on a given template (e.g., it is not nested within another Random section), then you may be able to set the number of sub-points, the "match maximum selections per sub-point", and then generate a specific number of resumes per batch such that each sub-point is selected some minimum number of times.
</ul>
</ol>

<h3>Repeating:</h3>This option is most useful for generating job histories where multiple jobs are picked from a single list.  If an outline point is set to "Repeat", then that point will be repeated some number of times (see Example 5 above).  When a resume is generated, a counter inside the program will be initialized to the 'start' value, and then incremented by the 'interval' value after each time the point is completed.  The repetitions will stop when the counter is equal to or past the 'end' value.
<p>When generating job histories, the user may desire for the same characteristic (i.e., previous jobs) not to be printed twice in succession.  Setting the option "Do not print doubles" will tell the program to not print the same characteristic upon successive repetitions until a different characteristic is chosen (see Examples 9&10).
<p>There are five settings that affect the probability of choosing the same characteristic in multiple repetitions.  The "Same when repeat" setting will choose the same characteristic on each repetition.  The "Always different when repeat" setting will prevent the resume from containing the same characteristic more than once.  ("Always different when repeat" is different from "Do not print doubles" because the former will print a different characteristic for each repetition, whereas the latter may only end up printing one characteristic.)  The third setting that affects probability is "Non-uniform chance for immediate repeat", which allows the experimenter to specify the exact chance of choosing the same subpoint that was chosen the last repetition.
<br>If "do not print doubles" is checked, then two more options will be possible: "minimum # of entries" and "maximum # of entries".  If an integer greater than zero is provided for the minimum, then the random section will force the last selections to be different if necessary for there to be that number of entries.  If a number greater than zero is provided for the maximum, then the random section will force the last selections to be the same if necessary for there to be no more than that number of entries.  Values of 0 or less for those entries will be ignored.
<br>These five settings are <em>mutually-exclusive</em> except for minimum & maximum number of entries.
<p>To assist with the creation of work histories, special text in a 'Leaf' will be replaced with values from the repetition counter (see Examples 9&10 above).  The purpose behind this feature is to allow the repetition over a set of jobs, where the description of each job contains the years worked.  Those years should increment as the work history is being created, and should follow the repetition counter.  The text %start% will be replaced with the start value.  %end% will be replaced with the end value.  %current% will be replaced with the value of the counter at the time of that choice.  %currentPlusInterval% will be replaced by the sum of the current value of the counter and the counting interval.
<br>%next% is also a special text, but it must be followed by the label of a 'Random' point and then a percent sign, '%', e.g., "%next%1-3-2%". (The "label" of a point is the string of numbers and minus signs directly to the left of the 'Leaf'/'Random'/'Constant'/'Dependent' drop-down box. The top point's label is 1, its first subpoint is 1-1, and its second subpoint is 1-2.) The %next% special text will be replaced by the current value of the specified counter when that repetition makes a different choice than it did previously.  If any %next% instances are not replaced before the repetitions finish, they will be replaced by the end value.
<p>Only 'Random' points can be marked "repeating".  To repeat a 'Constant', 'Dependent', or 'Leaf' point, create a repeating 'Random' point with a single subpoint that will then get chosen each repetition.

<h3>Dependent sections:</h3> Dependent sections are used to link a random selection at one place in the resume to another selection elsewhere in the resume.  When a 'Dependent' section is first added to a template, it will automatically depend upon the first 'Random' section in the template.  The drop-down box after "on section labeled" can be used to change which 'Random' section to depend upon.  The 'Dependent' section will automatically have the same number of subsections as the 'Random' section on which it depends.  If the template does not contain at least one 'Random' section above the 'Dependent' section, an error will be displayed.
<p>When the resume-randomizer program generates resumes from a template, the program stores the last choice for each 'Random' section.  When the program comes to a 'Dependent' section, it makes the same choice that was last made by the depended-upon 'Random' section.  For example, dependent sections are useful if you are generating resumes and you want the phone number to be dependent on the name, the year of high school graduation, or some other random selection made while generating the resume.  For another example, if you are generating resumes for different jobs at random and certain education entries need to be paired with certain certificates.  See Example 11 above.

<h3>File fragments:</h3> "File fragments" allow a template to load text from a separate file. For example, the example template "example_resume_template_with_fragments.rtf" provided with this software uses text contained in the "example_job_history_fragment.rtf" fragment to add text to the job history section of a resume. <em>The purpose of file fragments</em> is to simplify text entry of many leaf sections.  Without file fragments, the user must either enter the text for each leaf into this webpage, or learn all the text formatting required to write the template files manually.  Using file fragments, the complicated aspects of the template can be created using this webpage, while long lists of leaf sections can be collated into a plain text file using minimal formatting.
<p>To load a fragment, use the special text "%file%XXXXX%" at the start of a line, substituting a filename for the "XXXXX"; see section 1-3-2 of Example 13 above.  The first line of the named file should start with "*fragment*", and the file should contain leaf sections that start with a line "*leaf*" and end with a line "*end_leaf*", similar to the template format but without any section labels.  Any lines outside of a *leaf*...*end_leaf* block will be ignored, so blank lines can be inserted to make it easier to read the fragment file.  When the resume-randomizer.exe program is run, it checks the template for any %file% special texts, and inserts the fragments there as though the template contained those leaf subsections.  In the example, the %file% special text is in section 1-3-2, a leaf of the random section 1-3, so after the fragment is inserted, random section 1-3 will have a total of 5 subsections (Target, Wal-Mart, Starbucks, Office temp, and the Random section for Best Buy).
<p>File fragments can only contain "leaf" sections.
<p>File fragments can contain any special texts. Except for %next%, all the special texts are used the same as outside of a file fragment (including %file%, so file fragments can reference other file fragments).  Since the file fragment does not contain any "random" sections, it does not make sense to specify the label with the %next% special text.  Therefore, in file fragments (and only in file fragments), "%next%" is not followed by a label (or a third '%'), and instead will automatically refer to the repeating "random" section that is nearest to the %file% special text.
<p>Note, if you want a job history where each of the matched resumes gets an equivalent but different job title at each repetition, and you want to store those job titles in file fragments, here is one way: start with a random section, where each subsection is a Constant subsection containing a Leaf followed by a Random.  The Leaf would have the special text for the counter (aka date), e.g., "%next%1-3% - %current%".  Each Random section would be MatchDifferent, and would have a single Leaf subsection.  Those Leaf subsections would each reference a different file fragment (containing equivalent but different jobs)...note that you wouldn't want to put %current% or %next% in the file fragments, because the nearest Random would be the one with MatchDifferent.  So there might be a file fragment containing equivalent but different office jobs, then another fragment containing equivalent but different waitressing jobs, etc.
<p>Further note, if a dependent section points at a random section with one or more leaf subsections that contain file fragments, the gui will give the dependent section the wrong number of subsections.  In this case, use file fragments containing the exact same number of Leaf sections in both the Dependent section and the master Random section.

<h3>Template-created variables, %store% and %recall% special text:</h3>
Another way of having a Random section affect later text is through template-created variables.  When the '%store%XXXX%YYYY%' special text is encountered in a Leaf, a variable is stored with the name XXXX and the value YYYY, where XXXX and YYYY can be any combination of numbers, letters, spaces, and <em>some</em> symbols (underscore definitely works, the percent sign does not work).  When the '%recall%XXXX%' special text is encountered in a Leaf, the resume-randomizer program checks to see if a variable has been stored with the name XXXX, and if so, it replaces the special text with the value ('YYYY' above) that was stored in the variable with that name.  If no variable with that name has been stored, an error occurs.
<p>To put a newline inside a template-created variable, use \n, such as in Example 21.
<p>See Example 15 above, which uses template-created variables to create email addresses that are based on both the first name and the last name (and could be based on age, race, etc.) without nesting Random sections.  Also see Example 21, which uses newlines inside template created variables and demonstrates that the same variable can be stored multiple times.

  <h3>Batch/Resume count special texts:</h3>
  When used in Leaf sections, the following special texts will be replaced by numbers related to the number of resumes and batches generated.
  <p>If the resume contains one or more Random sections that are matching:
  <ul>
    <li><b>%numberofresumesperbatch%</b> will be replaced by the number of resumes in the batch.
    <li><b>%resume%</b> and <b>%resumepadded%</b> will be replaced by the number of this resume in the current batch (e.g., for a batch of 3 this will be replaced with 1 in the first resume and 3 in the last resume of the batch.)
    <li><b>%numberofbatches%</b> will be replaced by the number of batches being generated.
    <li><b>%batch%</b> and <b>%batchpadded%</b> will be replaced by 1 for the first batch, and n for the nth batch generated.
    <li><b>%totalnumberofresumes%</b> will be replaced by the result of (<b>%numberofbatches%</b> times <b>%numberofresumesperbatch%</b>).
    <li><b>%resumecountoverbatches%</b> and <b>%resumecountoverbatchespadded%</b> will be replaced by the result of (((<b>%batch%</b> - 1) times <b>%numberofresumesperbatch%</b>) plus <b>%resume%</b>), so it starts at 1 and increments with each resume generated within and across batches.
  </ul>

  <p>If the resume does not contain any matching sections, then each resume is treated as a separate batch:
  <ul>
    <li><b>%numberofresumesperbatch%</b> will be replaced by 1.
    <li><b>%resume%</b> and <b>%resumepadded%</b> will be replaced by 1.
    <li><b>%numberofbatches%</b> will be replaced by the number of resumes being generated from the template (i.e., the number entered at the prompt "How many resumes should be generated?").
    <li><b>%batch%</b> and <b>%batchpadded%</b> will be replaced by the number of this resume in the current generation of resumes (e.g., if 6 resumes are being created this will be replaced with 1 in the first resume and 6 in the last resume.)
    <li><b>%totalnumberofresumes%</b> will be replaced by the same value as <b>%numberofbatches%</b>.
    <li><b>%resumecountoverbatches%</b> and <b>%resumecountoverbatchespadded%</b> will be replaced by the same value as <b>%batch%</b>.
  </ul>
  <p>The special texts that end in 'padded' (<b>%batchpadded%</b>, <b>%resumepadded%</b>, and <b>%resumecountoverbatchespadded%</b>) have their values padded with zeros on the left, so that they will all be the same length across resumes and/or batches.  For example, if 100 resumes are generated (no matching) then for the first resume <b>%resumecountoverbatches%</b> will be '1', while <b>%resumecountoverbatchespadded%</b> will be '001'.
  <p>These special texts do not remember any previous resumes or batches generated. If you generate 1 batch of 1 resume, then generate 1 more batch of 1 resume: <b>%numberofbatches%</b>, <b>%batch%</b>, and <b>%resumeoverbatches%</b> will each be replaced by 1 in both of the generated resumes.

  <h3>Source, suggestions, and bug reports</h3>
  The source code is hosted on github <a href="https://github.com/beaslera/resumerandomizer">https://github.com/beaslera/resumerandomizer</a>. Issues and/or pull requests can be handled there.
<hr>
<h2><a name="changelog">Changelog</a></h2>
<small>
  <ul>
    <li>Version 30 on 12/4/2017: Template created variables can now contain tags for newlines. New example of having a header in the text if and only if there one or more Random sections will put text in that section.
    <li>Version 29 on 12/3/2017: Clarifies and rearranges instructions and descriptions on the webpage.  Adds batch special texts, e.g., %numberofbatches%, with an example. Example 14 now also randomizes the font.  Program now ignores any lines below the end tag for the first (top-level) section, even if the first section is Random or Leaf.  Adds example for printing a header dependent on the selections of any one of a set of Random sections.
    <li>Version 28 on 11/3/2017: Recoded html/javascript to enable use on Chrome and other webbrowsers (replaces iframes with divs, moves everything into one file). Some features removed: file load browser, scroll to change in template, resizable panels.  Adds an alert if gui fails trying to fix the %next% special text after a deletion. Adds link to github repo. Updates program to Python 3.6.2 with many changes to handling file encodings.  Bugfix in Repeating sections with non-decimel start/stop/interval parameters that resulted in too few repetitions. Line endings in input files will now be automatically converted to the system-specific to assist cross-platform templates.  Fixed bug making the sav file have an incorrect value for the number within a batch. Rearranged the instructive text at the top of sav files.
<li>Version 27 on 10/13/2017: Adds examples for factorial designs. Better error message if interval for repeating section is zero. Fixes bugs with "Add section here" and "Delete this section" buttons with respect to Dependent sections.
<li>Version 26 on 8/17/2017: The executable collates the csv files into a single file.
<li>Version 25 on 8/11/2017: Random sections can now be matched to have a maximum number of times that each sub-point can be selected in a batch. Also, the min & max number of entries now uses parseInt(Number(...)) to catch bad input when a number precedes non-numeric characters, such as 3aoeu).
<li>Version 24 on 11/8/2015: The csv files and codebook use underscores to separate the numbers in point labels.  For example, point 1-3-5-11 will be saved in the file as "v1_3_5_11".  This change is to help with importing the data into Stata (which drops dashes from variable names).
<li>Version 23 on 11/1/2015: The csv files and codebook prepend points with "v".  For example, point 1-3-5-11 will be saved in the file as "v1-3-5-11".  This change is to help with importing the data into Excel (which otherwise tries to format the point identifiers as dates), and Stata (which will not import variable names that start with numbers).
<li>Version 22 on 6/20/2015: Random sections can now have a non-uniform percentage change for the first sub-point. The executable provides more information if it runs into an error writing the codebook. Switched from parseFloat() to Number() because the former will convert '1xaoeu32' to the number 1, while the latter returns NaN. Added more information to alerts when parsing percentage inputs to floats fails. Textareas are now automatically resized to fill the width of the frames.
<li>Version 21 on 4/21/2014: The instructions now use the terms "Match Only One Ever" and "Match Different" to correspond to the text in the GUI.  The executable better handles malformed templates when creating the codebook.  A bug was fixed in which templates that are exactly the same except the later one is missing one or more leafs at the end will now generate a new codebook.  (Codebooks generated by the pre-bugfix code should not demonstrate any detrimental effects since the missing Leafs will be in the codebook but not in any of the generated text files.)  The executable's error messages have been updated to match the text used in the GUI, and the error handling is standardized so that all errors are associated with a unique return value.  The executable prints the date of its latest version.
<li>Version 20 on 2/7/2014: The executable prints the version number.
<li>Version 19 on 9/6/2013: Never overwrites the codebook, instead adding a unique number to the filename.  Requests a keypress when the resume generator encounters an error, to prevent the window from closing too quickly.  Ensures that the screen does not scroll when "hiding" sections in the template generator.  Clarifies instructions/explanations in template generator.  Prints error to webpage if the wrong html file is loaded.  Adds HTML meta tags.
<li>Version 18 on 3/12/2013: Creates a codebook from the template, each time the program runs.  The codebook is an xls file containing one line per Leaf, with the parent section, the leaf's number in the parent, and the Leaf's text.
<li>Version 17 on 11/21/2012: Removes two printed messages used when adding the functionality for minimum/maximum number of entries.
<li>Version 16 on 7/28/2012: Adds minimum number of entries and maximum number of entries, so that Repeating Random section can have a specified number of entries when "do not print doubles" is set.
<li>Version 15 on 7/12/2012: Adds output of csv files to facilitate loading the data into data analysis programs (e.g., Stata).  Updates Explanation section of webpage to describe the data files that are generated.  Clarifies the resume-randomizer.exe program's questions about the number of batches of matched resumes.
<li>Version 14 on 7/10/2012: Adds Matched Only One Ever, which is similar to Matched Different but with Matched Only One Ever each subsection of a random section (that repeats) can only ever be in one resume (think of it as choose-without-replacement).
<li>Version 13 on 7/10/2012: Bugfix: this webpage better checks for the start and end of sections (i.e., the tags *leaf*, *end_leaf*, etc). The textareas (for text entry above) now automatically resize.  <em>Inside file fragments</em> the *leaf* and *end_leaf* special text can now be followed by arbitrary text or spaces.  Can now specify whether or not to include the date & time on filenames.
<li>Version 12 on 7/8/2012: Bugfix: Now correctly handles unexpected end-of-file while reading templates.
<li>Version 11 on 7/4/2012: Adds example for templates that generate TeX documents.  Adds template-created variables (via %store% and %recall% special texts).
<li>Version 10 on 6/27/2012: Adds file fragments.  Adds example for templates that generate HTML documents.
<li>Version 9 on 6/20/2012: Bugfix: when adding a section the numbers got messed up. Adding and deleting sections now properly reloads to show a section near where the change occurred. When adding or deleting sections, dependent sections now update their master value appropriately, and %next% special text updates similarly.  Adds the browse button to load templates from disk, but the code does not work on Internet Explorer.  Also improves error checking so that resume-randomizer throws an error if %next% references a non-Random section, and to ensure that start/end/interval are either integers or floats.
<li>Version 8 on 5/25/2012: Adds Dependent sections.
<li>Version 7 on 6/22/2007: Edited the text explaining the webpage to the user to match the changes in the naming of files.  resume template files now end in .rtf instead of .dat
<li>Version 6 on 6/22/2007: Edited the text explaining the webpage to the user to match the changes in the naming of files.  .txt -> .doc and .raw -> .txt
<li>Version 5 on 6/22/2007: No changes.  Version number updated to correspond with the executable's version number.
<li>Version 4 on 6/22/2007: Edited the text explaining the webpage to the user.
<li>Version 3 on 6/22/2007: Edited the text explaining the webpage to the user.
<li>Version 2 on 6/22/2007: Replaced all instances of the text "style" with "template".
<li>Version 1 on 6/20/2007
</ul>
</small>
<p>Jump to: <a href="#basic">Basic Use</a>, <a href="#explanation">Explanation</a>, <a href="#createTemplate">Template Creation</a>, <a href="#files">Files</a>, <a href="#examples">Examples</a>, <a href="#advanced">Advanced Use</a>, <a href="#changelog">Changelog</a>.

<hr>
<small>Copyright 2015 Ryan Beasley and Joanna Lahey.</small>

</div>
<div id="sidebar">
<p><input type="button" value="Clear template" onClick="clearTemplateAndReloadAllAndRecenter()">
  <input type="button" value="Load this template" onClick="loadTemplate()">
  <input type="button" value="Select all" onClick="selectAll()">
</p>
<TEXTAREA id="templateText" rows="40" wrap="off"  onkeydown="return parent.insertTab(event,this);"></TEXTAREA>
</div>
</div>

</body>
</HTML>
